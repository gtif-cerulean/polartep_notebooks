<!DOCTYPE html><html lang="en" class="" style="scroll-padding:60px"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>PolarTEP Notebooks</title><meta property="og:title" content="PolarTEP Notebooks"/><meta name="generator" content="mystmd"/><meta name="description" content="Collection of examples relevant to the PolarTEP"/><meta property="og:description" content="Collection of examples relevant to the PolarTEP"/><meta name="keywords" content=""/><link rel="stylesheet" href="/polartep_notebooks/build/_assets/app-AIT5GAEP.css"/><link rel="stylesheet" href="/polartep_notebooks/build/_assets/thebe-core-VKVHG5VY.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jupyter-matplotlib@0.11.3/css/mpl_widget.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"/><link rel="icon" href="/polartep_notebooks/favicon.ico"/><link rel="stylesheet" href="/polartep_notebooks/myst-theme.css"/><script>
  const savedTheme = localStorage.getItem("myst:theme");
  const theme = window.matchMedia("(prefers-color-scheme: light)").matches ? 'light' : 'dark';
  const classes = document.documentElement.classList;
  const hasAnyTheme = classes.contains('light') || classes.contains('dark');
  if (!hasAnyTheme) classes.add(savedTheme ?? theme);
</script></head><body class="m-0 transition-colors duration-500 bg-white dark:bg-stone-900"><div class="myst-skip-to-article fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1" aria-label="skip to content options"><a href="#skip-to-frontmatter" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article frontmatter</a><a href="#skip-to-article" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article content</a></div><dialog id="myst-no-css" style="position:fixed;left:0px;top:0px;width:100vw;height:100vh;font-size:4rem;padding:1rem;color:black;background:white"><strong>Site not loading correctly?</strong><p>This may be due to an incorrect <code>BASE_URL</code> configuration. See<!-- --> <a href="https://mystmd.org/guide/deployment#deploy-base-url">the MyST Documentation</a> <!-- -->for reference.</p><script>
    (() => {
            // Test for has-styling variable set by the MyST stylesheet
            const node = document.currentScript.parentNode;
            const hasCSS = window.getComputedStyle(node).getPropertyValue("--has-styling");
            if (hasCSS === ""){
                    node.showModal();
            }

    })()
</script></dialog><div class="myst-top-nav bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 sticky w-screen top-0 z-30 h-[60px]"><nav class="myst-top-nav-bar flex items-center justify-between flex-nowrap max-w-[1440px] mx-auto"><div class="flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center shrink-0"><div class="block lg:hidden"><button class="myst-top-nav-menu-button flex items-center justify-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100 w-10 h-10"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem"><path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd"></path></svg><span class="sr-only">Open Menu</span></button></div><a class="myst-home-link flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7" href="/polartep_notebooks/"><span class="text-md sm:text-xl tracking-tight sm:mr-5">Made with MyST</span></a></div><div class="flex items-center flex-grow w-auto"><div class="flex-grow hidden text-md lg:block"></div><div class="flex-grow block"></div><button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R75cp:" data-state="closed" class="myst-search-bar flex items-center h-10 aspect-square sm:w-64 text-left text-gray-600 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 myst-search-bar-disabled hover:ring-blue-500 dark:hover:ring-blue-500 hover:border-blue-500 dark:hover:border-blue-500"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="p-2.5 h-10 w-10 aspect-square"><path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd"></path></svg><span class="myst-search-text-placeholder hidden sm:block grow">Search</span><div aria-hidden="true" class="myst-search-shortcut items-center hidden mx-1 font-mono text-sm text-gray-600 sm:flex gap-x-1"><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none hide-mac">CTRL</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none show-mac">âŒ˜</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none ">K</kbd><script>
;(() => {
const script = document.currentScript;
const root = script.parentElement;

const isMac = /mac/i.test(
      window.navigator.userAgentData?.platform ?? window.navigator.userAgent,
    );
root.querySelectorAll(".hide-mac").forEach(node => {node.classList.add(isMac ? "hidden" : "block")});
root.querySelectorAll(".show-mac").forEach(node => {node.classList.add(!isMac ? "hidden" : "block")});
})()</script></div></button><button class="myst-theme-button theme rounded-full aspect-square border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 w-10 h-10 mx-3" title="Toggle theme between light and dark mode" aria-label="Toggle theme between light and dark mode"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-moon-icon h-full w-full p-0.5 hidden dark:block"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z" clip-rule="evenodd"></path></svg><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-sun-icon h-full w-full p-0.5 dark:hidden"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"></path></svg></button><div class="block sm:hidden"></div><div class="hidden sm:block"></div></div></nav></div><div class="myst-primary-sidebar fixed xl:article-grid grid-gap xl:w-screen xl:pointer-events-none overflow-auto max-xl:min-w-[300px] lg:hidden hidden z-10" style="top:60px"><div class="myst-primary-sidebar-pointer pointer-events-auto xl:col-margin-left flex-col overflow-hidden hidden xl:flex"><div class="myst-primary-sidebar-nav flex-grow py-6 overflow-y-auto primary-scrollbar"><nav aria-label="Navigation" class="myst-primary-sidebar-topnav overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px] lg:hidden"><div class="w-full px-1 dark:text-white font-medium"></div></nav></div></div></div><main class="article-grid grid-gap"><article class="article-grid subgrid-gap col-screen article content"><div class="hidden"></div><div id="skip-to-frontmatter" aria-label="article frontmatter" class="myst-fm-block mb-8 pt-9"><div class="myst-fm-block-header flex items-center mb-5 h-6 text-sm font-light"><div class="myst-fm-block-subject flex-none pr-2 smallcaps">Notebook examples</div><div class="flex-grow"></div><div class="myst-fm-block-badges"><a href="https://github.com/gtif-cerulean/polartep_notebooks" title="GitHub Repository: gtif-cerulean/polartep_notebooks" target="_blank" rel="noopener noreferrer" class="myst-fm-github-link text-inherit hover:text-inherit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" width="1.25rem" height="1.25rem" class="myst-fm-github-icon inline-block mr-1 opacity-60 hover:opacity-100"><path d="M12 2.5c-5.4 0-9.8 4.4-9.8 9.7 0 4.3 2.8 8 6.7 9.2.5.1.7-.2.7-.5v-1.8c-2.4.5-3.1-.6-3.3-1.1-.1-.3-.6-1.1-1-1.4-.3-.2-.8-.6 0-.6s1.3.7 1.5 1c.9 1.5 2.3 1.1 2.8.8.1-.6.3-1.1.6-1.3-2.2-.2-4.4-1.1-4.4-4.8 0-1.1.4-1.9 1-2.6-.1-.2-.4-1.2.1-2.6 0 0 .8-.3 2.7 1 .8-.2 1.6-.3 2.4-.3.8 0 1.7.1 2.4.3 1.9-1.3 2.7-1 2.7-1 .5 1.3.2 2.3.1 2.6.6.7 1 1.5 1 2.6 0 3.7-2.3 4.6-4.4 4.8.4.3.7.9.7 1.8V21c0 .3.2.6.7.5 3.9-1.3 6.6-4.9 6.6-9.2 0-5.4-4.4-9.8-9.8-9.8z"></path></svg></a></div><a href="https://github.com/gtif-cerulean/polartep_notebooks/edit/main/notebooks/ccadi_UC3.ipynb" title="Edit This Page" target="_blank" rel="noopener noreferrer" class="myst-fm-edit-link text-inherit hover:text-inherit"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.25rem" height="1.25rem" class="myst-fm-edit-icon inline-block mr-1 opacity-60 hover:opacity-100"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10"></path></svg></a><div class="myst-fm-downloads-dropdown relative flex inline-block mx-1 grow-0" data-headlessui-state=""><button class="myst-fm-downloads-button relative ml-2 -mr-1" id="headlessui-menu-button-:Rs8ucp:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Downloads</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.25rem" height="1.25rem" class="myst-fm-downloads-icon"><title>Download</title><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"></path></svg></button></div></div></div><div class="block my-10 lg:sticky lg:z-10 lg:h-0 lg:pt-0 lg:my-0 lg:ml-10 lg:col-margin-right" style="top:60px"><nav></nav></div><div id="skip-to-article"></div><div id="VKzx1IWnOI" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">!pip3 install altair===4.2.2
!pip3 install PyCO2SYS==1.8.2
!pip3 install leafmap==0.17.1
!pip3 install erddapy===1.2.1
!pip3 install ipywidgets==8.0.4</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="5N4AKXR-IVgpwoKSCz4lL" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="Nf1VUJsej4" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">import urllib.request as request
import h5py
import os
from ipywidgets import widgets, IntSlider, jslink, interact, interactive, fixed, interact_manual
import markdown
from erddapy import ERDDAP
from ipyleaflet import Map, Marker, GeoData, ImageOverlay, basemaps, basemap_to_tiles, LayersControl, ScaleControl, FullScreenControl, WidgetControl
# import pandas as pd
import numpy as np
# from IPython.display import display
from netCDF4 import num2date
# from datetime import datetime
import geopandas as gpd
########################################################
import sys
import pandas as pd
import ipywidgets as widgets
from IPython.display import Markdown, HTML, Javascript, display, Image
import subprocess
import csv
from __future__ import print_function
# from ipywidgets import interact, interactive, fixed, interact_manual
import csv
import re
import warnings
#from init import *
warnings.simplefilter(action=&#x27;ignore&#x27;, category=pd.errors.PerformanceWarning)
def printmd(string):
    display(Markdown(string))
###############################################################
from ftplib import FTP
import multiprocessing as mlp
import shutil
import tempfile
import urllib.request
from datetime import datetime, timedelta

from osgeo import gdal
# import numpy as np
from osgeo import ogr
from osgeo import osr
# import pandas as pd
import pyproj

from multiprocessing import Manager
# from ipywidgets import widgets, IntSlider, jslink
from ipyleaflet import Map, projections, GeoData, basemap_to_tiles, basemaps, WidgetControl, ScaleControl, FullScreenControl, LayersControl #, ImageOverlay, 
import geopandas as gpd
import leafmap
import altair as alt
# import localtileserver  # was needed localy to be able to add raster on the leafmap Map.</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="gDhQMcYHlkpABKGaz0O1K" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="vtBs0Cunet" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">class merge_btl_nutrient:
    
    def get_btlfile(self, btl_url, wdir):
        request.urlretrieve(btl_url, os.path.join(wdir, &quot;btl.h5&quot;))
        return 0

    def btl_to_dataframe(self, wdir):
        f = h5py.File(os.path.join(wdir, &quot;btl.h5&quot;), &#x27;r&#x27;)
        df_btl = pd.DataFrame()
        for grp in f:
            tempo_list = []
            tempo_columns = []
            for c in f[grp]:
                tempo_columns.append(c)
                tempo_list.append(f[grp][c])
            list_array = np.transpose(np.array(tempo_list))
            tempo_df = pd.DataFrame(list_array, columns=tempo_columns)
            tempo_df[&#x27;station&#x27;] = [f[grp].attrs[&#x27;Station&#x27;].strip().split(&#x27; &#x27;)[-1]] * len(tempo_df)
            tempo_df[&#x27;cast&#x27;] = [int(f[grp].attrs[&#x27;Cast_Number&#x27;].strip())] * len(tempo_df)
            df_btl = pd.DataFrame.append(tempo_df, df_btl)
        f.close()
#         # added to extract a csv format of the btl.h5 data to send out to the GUI team
#         df_btl.to_csv(os.path.join(wdir, &quot;btl.csv&quot;), header=1, index=0)
        #######
        return df_btl

    def merge(self, df_nutrient, df_btl, file_ge_btl):
        ge_time_header = [i for i in list(df_nutrient.columns) if
                          ((i.lower().__contains__(&#x27;date&#x27;)) or 
                           (i.lower().__contains__(&#x27;time&#x27;)))].pop()
        btl_time_header = [i for i in list(df_btl.columns) if
                           ((i.lower().__contains__(&#x27;date&#x27;)) or 
                           (i.lower().__contains__(&#x27;time&#x27;)))].pop()
        ge_station_header = [i for i in list(df_nutrient.columns) if
                             i.lower().__contains__(&#x27;station&#x27;)].pop()
        btl_station_header = [i for i in list(df_btl.columns) if
                              i.lower().__contains__(&#x27;station&#x27;)].pop()
        ge_bottle_header = [i for i in list(df_nutrient.columns) if
                            (i.lower().__contains__(&#x27;bottle&#x27;))].pop()
        &quot;&quot;&quot; TODO: bopo should be replacet with RosPos when the data with the corrected variable name will be served on Hyrax.&quot;&quot;&quot;
        btl_bottle_header = [i for i in list(df_btl.columns) if
                             i.lower().__contains__(&#x27;bopo&#x27;)].pop() 
        ge_cast_header = [i for i in list(df_nutrient.columns) if
                          i.lower().__contains__(&#x27;cast&#x27;)].pop()
        btl_cast_header = [i for i in list(df_btl.columns) if
                           i.lower().__contains__(&#x27;cast&#x27;)].pop()
        ge_jointField = [ge_time_header, ge_station_header, ge_bottle_header, ge_cast_header]
        btl_jointField = [btl_time_header, btl_station_header, btl_bottle_header, btl_cast_header]
        
        #####################################
        df_nutrient_header = [h.split(&#x27; &#x27;)[0] for h in df_nutrient.columns]
        df_nutrient.columns = df_nutrient_header
        dfnutrient_to_merge = df_nutrient
        dfbtl_to_merge = df_btl
        dfbtl_to_merge = dfbtl_to_merge.drop(btl_time_header, axis=1)
        dfnutrient_to_merge = dfnutrient_to_merge.drop(ge_time_header, axis=1)
        dfnutrient_to_merge = dfnutrient_to_merge.drop(ge_station_header, axis=1)
        dfnutrient_to_merge[ge_time_header] = pd.to_datetime(df_nutrient[ge_time_header]).dt.strftime(&#x27;%Y-%m-%d&#x27;)
        # dfnutrient_to_merge[ge_time_header] = df_nutrient[ge_time_header].dt.strftime(&#x27;%Y-%m-%d&#x27;)
        u = []
        for i in df_nutrient[ge_station_header].values:
            if i.isdigit():
                u.append(&#x27;G&#x27; + i)
            else:
                u.append(i)
        dfnutrient_to_merge[ge_station_header] = u
        hdf_time_units = &quot;days since 1970-01-01 00:00:00&quot;
        list_tmp = []
        import cftime
        for i in range(len(df_btl[btl_time_header])):
            u=num2date(df_btl[btl_time_header].values[i], hdf_time_units)
            u=cftime.DatetimeGregorian.strftime(u, &#x27;%Y-%m-%d&#x27;)
            list_tmp.append(u)
        dfbtl_to_merge[btl_time_header] = list_tmp
        &#x27;&#x27;&#x27;https://www.datasciencemadesimple.com/join-merge-data-frames-pandas-python/&#x27;&#x27;&#x27;
        df = pd.merge(dfnutrient_to_merge, dfbtl_to_merge, how=&quot;inner&quot;, left_on=ge_jointField, right_on=btl_jointField)
        df.to_csv(file_ge_btl, header=1, index=0)
        del df
        return 0


class merging_gui_jupiter():
    # This is the class where the GUI is made
    def __init__(self):
        self.gridwindow={} # making an empty grid window
        self.vbox_widgets = [] # making an empty vertical box
        self.gridwindow[&#x27;grid&#x27;] = widgets.GridspecLayout(1, 1)
        #####
        self.getBTLbutton = widgets.Button(description=&quot;retrieve&quot;, layout=widgets.Layout(width=&#x27;max-content&#x27;), button_style=&#x27;info&#x27;)
        self.getNutrientbutton = widgets.Button(description=&quot;retrieve&quot;, layout=widgets.Layout(width=&#x27;max-content&#x27;), button_style=&#x27;info&#x27;)
        self.Continuebutton = widgets.Button(description=&quot;Continue&quot;, layout=widgets.Layout(width=&#x27;max-content&#x27;))
        # BTL file retrieval
        layout = widgets.Layout(height=&#x27;auto&#x27;, width=&#x27;125px&#x27;)
        printmd(&#x27;&lt;h1&gt;&lt;b&gt;Merging bottle file with the nutrient file&lt;/b&gt;&lt;/h1&gt;&#x27;)
        # read text
        f=open(os.environ[&quot;DATA_PATH&quot;] + &quot;/md_texts/nutrient_btl_infos.md&quot;,&quot;r&quot;)
        fc=f.read()
        f.close()
        text_html1 = markdown.markdown(fc)
        del fc
        self.gridwindow[&#x27;text1&#x27;] = widgets.HTML(text_html1)
#         # Reading the images of the CTD-Rosette ##########
        ctd_img = open(os.environ[&quot;DATA_PATH&quot;] + &quot;/images/ctd-rosette.jpg&quot;, &quot;rb&quot;)
        ship_img = open(os.environ[&quot;DATA_PATH&quot;] + &quot;/images/CCGSAmundsen.png&quot;, &#x27;rb&#x27;)
        ctd = ctd_img.read()
        ship = ship_img.read()
        gridimage1 = widgets.Image(value=ship, format=&#x27;jpg&#x27;, width=300)
        Figure1 = widgets.Label(r&#x27;\(\textbf{Figure 1:}\)&#x27;+&#x27; Canadian Coast Guard Ship &#x27; + r&#x27;\(\textit{Amundsen}\)&#x27;, layout=widgets.Layout(height=&#x27;auto&#x27;, width=&#x27;auto&#x27;))
        gridimage2 = widgets.Image(value=ctd, format=&#x27;png&#x27;, width=300)
        Figure2 = widgets.Label(r&#x27;\(\textbf{Figure 2:}\)&#x27;+&#x27; CTD-Rosette&#x27;, layout=widgets.Layout(height=&#x27;auto&#x27;, width=&#x27;auto&#x27;))
        ship_img.close()
        ctd_img.close()
        image_vbox1 = widgets.VBox(children=[gridimage1, Figure1])
        image_vbox2 = widgets.VBox(children=[gridimage2, Figure2])
        self.gridwindow[&#x27;image&#x27;] = widgets.HBox(children=[image_vbox1, image_vbox2])
# #         image_vbox = [[gridimage1, gridimage2], [&#x27;CCGS Amundsen&#x27;, &#x27;CTD-Rosette&#x27;]]
#         gridwindow[&#x27;image&#x27;] = widgets.HBox(children=[gridimage2, gridimage1])
        ###################################################
        self.vbox_widgets.append(self.gridwindow[&#x27;text1&#x27;])
        self.vbox_widgets.append(self.gridwindow[&#x27;image&#x27;])
        
                # read text
        f=open(os.environ[&quot;DATA_PATH&quot;] + &quot;/md_texts/data_retrieval.md&quot;,&quot;r&quot;)
        fc=f.read()
        f.close()
        data_retrieval = markdown.markdown(fc)
        del fc
        self.gridwindow[&#x27;data_retrieval&#x27;] = widgets.HTML(data_retrieval)
        self.vbox_widgets.append(self.gridwindow[&#x27;data_retrieval&#x27;])
        ## Bottle file retrieval ######
        label = widgets.Label(&#x27;Bottle files&#x27;, layout=layout)
        self.BottleData = widgets.Text(
            value=&quot;http://jorvik.uwaterloo.ca:8080/opendap/data/CCADI/Amundsen_BTL_GreenEdge2016_LEG1.h5&quot;,
            layout=widgets.Layout(width=&#x27;50%&#x27;)
        )
        self.gridwindow[&#x27;bottle&#x27;] = widgets.HBox(children=[label, self.BottleData, self.getBTLbutton])
        self.vbox_widgets.append(self.gridwindow[&#x27;bottle&#x27;])
        label = widgets.Label(&#x27;Nutrient file&#x27;, layout=layout)
        self.nutrientServer = widgets.Text(
            value=&quot;https://CanWINerddap.ad.umanitoba.ca/erddap&quot;,
            layout=widgets.Layout(width=&#x27;50%&#x27;)
        )
        self.gridwindow[&#x27;nutrientserver&#x27;] = widgets.HBox(children=[label, self.nutrientServer, self.getNutrientbutton])
        self.vbox_widgets.append(self.gridwindow[&#x27;nutrientserver&#x27;])
        
        self.list0 = widgets.SelectMultiple(
            options=[&quot;Empty&quot;],
            value=[&quot;Empty&quot;],
            disabled=False
        )

        self.list1 = widgets.SelectMultiple(
            options=[&quot;Empty&quot;],
            value=[&quot;Empty&quot;],
            disabled=False
        )
        
        self.depthRange = widgets.FloatRangeSlider(
                value=[0, 0],
                min=0,
                max=5000,
                step=0.1,
                disabled=False,
                continuous_update=False,
                orientation=&#x27;horizontal&#x27;,
                readout=True,
                readout_format=&#x27;.1f&#x27;,
        )
        
        self.outputdir = &quot;2016_int_btl_csv&quot;
        self.gridwindow[&#x27;grid&#x27;][0, 0] = widgets.VBox(children=self.vbox_widgets)  # pass all the content of the vertical box into the left side of the grid
        
        self.getBTLbutton.on_click(self.getBTLdata)
        self.getNutrientbutton.on_click(self.getNutrientdata)
        display(self.gridwindow[&#x27;grid&#x27;])
        self.Merge_Button=widgets.Button(
            description=&#x27;Merge&#x27;,
            disabled=False,
            button_style=&#x27;&#x27;, 
            tooltip=&#x27;Click me&#x27;,
            icon=&#x27;&#x27;
            )
        self.merge_btl_nutrient()
        
        
        ###########
             
    def continue_to_pyco2sys(self): 
        def on_button_pyco2sys(b):
            continueprocess()

        outmerge=widgets.Output()
        @outmerge.capture()
        def continueprocess():
            checkInputfile()
#             self.continue_to_sic()
        
        gridwindow={}
        vbox_widgets = []
        gridwindow[&#x27;grid&#x27;] = widgets.GridspecLayout(1,1)
        layout = widgets.Layout(height=&#x27;auto&#x27;, width=&#x27;125px&#x27;)
        f=open(os.environ[&quot;DATA_PATH&quot;] + &quot;/md_texts/variable_Join_list.md&quot;,&quot;r&quot;)
        fc=f.read()
        f.close()
        text_var_sel = markdown.markdown(fc)
        del fc
        gridwindow[&#x27;variable_selection&#x27;] = widgets.HTML(text_var_sel)
        vbox_widgets.append(gridwindow[&#x27;variable_selection&#x27;])
        label = widgets.Label(&#x27;Bottle_variables&#x27;, layout=widgets.Layout(width=&#x27;50%&#x27;))
        label = widgets.Label(&#x27;Nutrient variables&#x27;, layout=widgets.Layout(width=&#x27;50%&#x27;))
        gridwindow[&#x27;bottle variable list&#x27;] = widgets.HBox(children=[label, self.list0])

        gridwindow[&#x27;nutrient variable list&#x27;] = widgets.HBox(children=[label, self.list1])
        gridwindow[&#x27;var_list&#x27;] = widgets.HBox(children=[gridwindow[&#x27;bottle variable list&#x27;], gridwindow[&#x27;nutrient variable list&#x27;]])
        vbox_widgets.append(gridwindow[&#x27;var_list&#x27;])
        label = widgets.Label(&#x27;Sample depth:&#x27;, layout=layout)
        # read text
        f=open(os.environ[&quot;DATA_PATH&quot;] + &quot;/md_texts/variable_meaning.md&quot;,&quot;r&quot;)
        fc=f.read()
        f.close()
        text_var = markdown.markdown(fc)
        del fc
        gridwindow[&#x27;variable_meaning&#x27;] = widgets.HTML(text_var)
        # read text
        f=open(os.environ[&quot;DATA_PATH&quot;] + &quot;/md_texts/sample_depth_range.md&quot;,&quot;r&quot;)
        fc=f.read()
        f.close()
        text_var_sel = markdown.markdown(fc)
        del fc
        gridwindow[&#x27;sample_depth_range&#x27;] = widgets.HTML(text_var_sel)
        vbox_widgets.append(gridwindow[&#x27;sample_depth_range&#x27;])
        gridwindow[&#x27;Sample depth&#x27;] = widgets.HBox(children=[label, self.depthRange])
        vbox_widgets.append(gridwindow[&#x27;Sample depth&#x27;])

        self.btl = pd.DataFrame()
        self.nutrient=pd.DataFrame()
        
        continue_button1=widgets.Button(
            description=&#x27;Continue&#x27;,
            disabled=False,
            button_style=&#x27;&#x27;, 
            tooltip=&#x27;Click me&#x27;,
            icon=&#x27;&#x27;
            )
        gridwindow[&#x27;merge&#x27;] = widgets.HBox(children=[self.Merge_Button])
        gridwindow[&#x27;to_pyco2sys&#x27;] = widgets.HBox(children=[gridwindow[&#x27;merge&#x27;], continue_button1])
        vbox_widgets.append(gridwindow[&#x27;to_pyco2sys&#x27;])
        gridwindow[&#x27;grid&#x27;][0, 0] = widgets.VBox(children=vbox_widgets)
        self.Merge_Button.on_click(self.clickMerge)
        continue_button1.on_click(on_button_pyco2sys)
        display(gridwindow[&#x27;grid&#x27;])
        display(outmerge)
        return 0       


        
    def merge_btl_nutrient(self): 
        def on_button_continuemerge(b):
            continuemerge()

        out=widgets.Output()
        @out.capture()
        def continuemerge():           
            ###### transit to the PyCO2SYS #####
            self.continue_to_pyco2sys()
            

        self.continue_button=widgets.Button(
            description=&#x27;continue&#x27;,
            disabled=False,
            button_style=&#x27;&#x27;, 
            tooltip=&#x27;Click me&#x27;,
            icon=&#x27;&#x27;
            )
        self.gridwindow[&#x27;continue&#x27;] = widgets.HBox(children=[self.continue_button])
        self.vbox_widgets.append(self.gridwindow[&#x27;continue&#x27;])
        self.gridwindow[&#x27;grid&#x27;][0, 0] = widgets.VBox(children=self.vbox_widgets)
        self.continue_button.on_click(on_button_continuemerge)
        display(out)

    def getBTLdata(self,a):
        if not os.path.exists(self.outputdir):
            os.makedirs(self.outputdir)
        merge_btl_nutrient().get_btlfile(self.BottleData.value, self.outputdir)
        df_btl=merge_btl_nutrient().btl_to_dataframe(self.outputdir)
        self.list0.options=tuple(df_btl.columns)
        self.list0.value=[&quot;BOPO&quot;,&quot;CTDTmp90&quot;,&quot;Cast_Number&quot;,&quot;P_sal_CTD&quot;,&quot;Pres_Z&quot;,&quot;depth&quot;,&quot;latitude&quot;,&quot;longitude&quot;,&quot;time&quot;,&quot;station&quot;]
        self.list0.rows = 24
        self.depthRange.min = df_btl[&#x27;depth&#x27;].min()
        self.depthRange.max = df_btl[&#x27;depth&#x27;].max()
        self.depthRange.value = [self.depthRange.min, self.depthRange.max]
        self.getBTLbutton.description=&quot;Success!&quot;
        self.getBTLbutton.button_style=&#x27;success&#x27;
        del df_btl
        return 0
    
    def getNutrientdata(self, a):
        if not os.path.exists(self.outputdir):
            os.makedirs(self.outputdir)
        e_DataSearch = ERDDAP(server=self.nutrientServer.value)
        result_search = e_DataSearch.get_search_url(search_for=&quot;greenedge&quot;, response=&quot;csv&quot;)
        self.datasetID = [k 
                          for k in pd.read_csv(result_search)[&quot;Dataset ID&quot;] 
                          if k.lower().__contains__(&quot;greenedge_nutrient&quot;)].pop()
        #self.datasetID = pd.read_csv(result_search)[&quot;Dataset ID&quot;][0]
        #print(result_search)

        e_datafetch = ERDDAP(server=self.nutrientServer.value, protocol=&quot;tabledap&quot;, response=&quot;csv&quot;)
        e_datafetch.dataset_id = self.datasetID

        df_nutrient = e_datafetch.to_pandas(parse_dates=True)
        file_ge = os.path.join(self.outputdir, f&#x27;{self.datasetID}.csv&#x27;)  ## Nutrient file name 
        df_nutrient.to_csv(file_ge, index=False, header=True)
        self.list1.options=df_nutrient.columns
        &quot;&quot;&quot; Adjustment done in order to look easily for the variables needed in the data field&quot;&quot;&quot;
        station = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;station&quot;)].pop()
        sample_date = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;sample_date&quot;)].pop()
        #sample_date = sample_date.split(&quot; &quot;)[0]
        sample_depth = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;sample_depth&quot;)].pop()
        #sample_depth = sample_depth.split(&quot; &quot;)[0]
        cast = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;cast&quot;)].pop()
        bottle = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;bottle&quot;)].pop()
        dic_um = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;dic_um&quot;)].pop()
        #dic_um = dic_um.split(&quot; &quot;)[0]
        totalk = [k for k in df_nutrient.columns if k.lower().__contains__(&quot;totalk_l_um&quot;)].pop()
        #totalk = totalk.split(&quot; &quot;)[0]
        self.list1.value=[station, sample_date, sample_depth, cast, bottle,dic_um, totalk]
        self.list1.rows = 24
        self.getNutrientbutton.description=&quot;Success!&quot;
        self.getNutrientbutton.button_style=&#x27;success&#x27;
        del df_nutrient
        return 0

        
    def clickMerge(self, a):
        file_ge_btl = os.path.join(self.outputdir, &#x27;merged_btl_nutrient.csv&#x27;) ## Merged file name to be fed to the PyCO2SYS
        objectsForMerging = merge_btl_nutrient()
        if os.path.exists(file_ge_btl):
            os.remove(file_ge_btl)
            df_btl = objectsForMerging.btl_to_dataframe(self.outputdir)
            df_btl.reset_index(drop=True, inplace=True)
            cond = (df_btl[&quot;depth&quot;].values[:]&gt;=self.depthRange.value[0]) &amp; (df_btl[&quot;depth&quot;].values[:]&lt;=self.depthRange.value[1])
            df_btl = df_btl.loc[cond]
            df_nutrient = pd.read_csv(os.path.join(self.outputdir, f&#x27;{self.datasetID}.csv&#x27;), header=0)            
            objectsForMerging.merge(df_nutrient=df_nutrient[list(self.list1.value)], df_btl=df_btl[list(self.list0.value)], file_ge_btl=file_ge_btl)
            del df_nutrient, df_btl
        else:
            df_btl = objectsForMerging.btl_to_dataframe(self.outputdir)
            df_btl.reset_index(drop=True, inplace=True)
            cond = (df_btl[&quot;depth&quot;].values[:]&gt;=self.depthRange.value[0]) &amp; (df_btl[&quot;depth&quot;].values[:]&lt;=self.depthRange.value[1])
            df_btl = df_btl.loc[cond]
            df_nutrient = pd.read_csv(os.path.join(self.outputdir, f&#x27;{self.datasetID}.csv&#x27;), header=0)            
            objectsForMerging.merge(df_nutrient=df_nutrient[list(self.list1.value)], df_btl=df_btl[list(self.list0.value)], file_ge_btl=file_ge_btl)
            del df_nutrient, df_btl
        self.Merge_Button.description=&quot;Done&quot;
        self.Merge_Button.button_style=&quot;success&quot;
        return 0

</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="WzuA0FdNWEj7YUmfYwdIF" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="ffOc5VCoKD" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">#Define the required parameters

def checkInputfile():
    #Create an empty list for all the required parameters in the file. 
    req_param_inFile=[]
    opt_param_inFile=[]
    
    pd.set_option(&#x27;display.max_columns&#x27;, 50)
    
    #-------------------INPUT FILE-------------------------------------------
    input_file =os.path.join(&quot;2016_int_btl_csv&quot;, &quot;merged_btl_nutrient.csv&quot;)                
    df = pd.read_csv(input_file)
    df=df.reset_index(drop=True)
    #------------------------------------------------------------------------
    
    #Checking for the stadardized names in the input file to automatically pull out all the required, optional and mandatory parameters present
    
    # 1. KEY PARAMETERS 
    # Parameters- Total Alkalinity, DIC, PH, PCO2, fCO2, CO232, biCO2
    
    standardizedNames=[&#x27;TotAlk_l_um_l&#x27;,&#x27;DIC_um_l&#x27;,&#x27;pH&#x27;,&#x27;pCO2&#x27;,&#x27;fCO2&#x27;,&#x27;CO232&#x27;,&#x27;biCO2&#x27;] #BODC standardized names
    fullNames=[&#x27;Total alkalinity (umolkg1)&#x27;,&#x27;Dissolved inorganic carbon (umolkg1)&#x27;,&#x27;Partial pressure of carbon dioxide (pCO2) (uatm)&#x27;,\
               &#x27;Fugacity of carbon dioxide (fCo2) (uatm)&#x27;,&#x27;Carbonate ion concentration (CO32) (umolkg1)&#x27;,&#x27;Bicarbonate ion (umol kg1)&#x27;]   # Full name that will show up in widget
    
    
    for name, fname in zip(standardizedNames, fullNames): 
        if name in df.columns:
            req_param_inFile.append(fname) #Append the names of all the key parameters in the input file
        
    
    # 2. OPTIONAL PARAMETERS 
    # Parameters- SiOx, PO4, Ammonia, Sulfide
    
    standardizedNames=[&#x27;SiOx_um_l&#x27;,&#x27;PO4_Filt_um_l&#x27;,&#x27;Ammonia&#x27;,&#x27;Sulfide&#x27;] #BODC standardized names
    fullNames=[&#x27;Total Silicate (umolkg1)&#x27;,&#x27;Total Phosphate (SRP) (umolkg1)&#x27;,&#x27;Total Ammonia (umolkg1)&#x27;,&#x27;Total Sulfide (umolkg1)&#x27;]   # Full name that will show up in widget
    
    for name, fname in zip(standardizedNames, fullNames): 
        if name in df.columns:
            opt_param_inFile.append(fname) #Append the names of all the key parameters in the input file
    
    
    getUserParameters(df, req_param_inFile, opt_param_inFile) 
</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="dk8zlzIIIciTHFbcCb5ze" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="l301QDkpcx" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def getUserParameters(df,req_param_inFile,opt_param_inFile):

    #The user will be presented with the parameters automatically pulled out from the input file. They will have a chance to make changes to the selections. 
    #Only exception is if there are only two req parameters in input file, they will not be able to make any changes/selctions in this case.
    
    #Key Parameters Widget
    req_param_user=widgets.SelectMultiple(
        options=req_param_inFile,
        #value=req_param_inFile,
        #description=&#x27;Key Parameters:&#x27;,
        disabled=False,
    )
    req_param_user.layout.margin=&#x27;0.5% 0% 5% 0%&#x27;
    req_param_user.layout.width=&#x27;20%&#x27;
    req_param_user.layout.height=&#x27;70%&#x27;


    #Optional Parameters Widget
    opt_param_user=widgets.SelectMultiple(
        options=opt_param_inFile,
        value=opt_param_inFile,
        #description=&#x27;Optional Parameters:&#x27;,
        disabled=False,
    )
    opt_param_user.layout.margin=&#x27;0.5% 0% 3% 0%&#x27;
    opt_param_user.layout.width=&#x27;20%&#x27;

    cont_button1=widgets.Button(
    description=&#x27;Continue&#x27;,
    disabled=False,
    button_style=&#x27;&#x27;, 
    tooltip=&#x27;Click me&#x27;,
    icon=&#x27;&#x27;
    )

    
    # Onclick function for the first Continue button widget
    output = widgets.Output()
    @output.capture()
    def on_button_clicked(b):
        getConstants(df, req_param_user, opt_param_user, req_param_inFile, opt_param_inFile)
    

    # Key parameters, aka carbonate system parameters
    printmd(&#x27;### &lt;br&gt;&lt;br/&gt; Carbonate System Parameters ###&#x27;) 
    printmd(&#x27;More information on these arguments an be found [here](https://pyco2sys.readthedocs.io/en/latest/co2sys_nd/#carbonate-system-parameters).&#x27;)
    #if there is only one or no key parameters in input file
    if len(req_param_inFile)&lt;2:
        printmd(&quot;&lt;br&gt;**There are not enough key parameters for calculation of the full carbonate system. Please check input file and try again.**&lt;br /&gt;&quot;)
        sys.exit(-1)
    
    #If only two key parameters in the input file, automatically use those two
    if len(req_param_inFile)==2:
        printmd(&quot;&lt;br&gt;**The following key carbonate parameters were found in the input file and will be used in calculations.**&lt;br /&gt;&quot;)

        for name in req_param_inFile:
            printmd(&#x27;- {}&#x27;.format(name))
 
    #If there are more than two key parameters in the input file, ask user to select any two
    if len(req_param_inFile)&gt;2:
        printmd(&quot;&lt;br&gt;**The following key carbonate parameters were found in the input file. Choose any two parameters.**&lt;br /&gt;&quot;)
        display(req_param_user) #display widget


    # Optional parameters, aka Nutrients &amp; solutes
    printmd(&#x27;### &lt;br&gt;&lt;br/&gt; Nutrients and other solutes ###&#x27;) 
    printmd(&#x27;More information on these arguments an be found [here](https://pyco2sys.readthedocs.io/en/latest/co2sys_nd/#nutrients-and-other-solutes).&#x27;)
    
    # If there is at least one opt parameter in file, display them and ask user to select any of them. All are automatically selected in the widget
    if len(opt_param_inFile)&gt;0:
        printmd(&quot;&lt;br&gt;**The following nutrient parameters are in the input file. Choose any parameter(s).**&lt;/b&gt;&quot;)
        display(opt_param_user)   #display widget
    
    
    display(cont_button1) #display continue button
    cont_button1.on_click(on_button_clicked)  #Call onclick function
    display(output) #display widget ouput when button is clicked
    </code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="Wi1_I6-eK8-aq57yqbi-4" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="veu0XAQ6Ua" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def getConstants(df, req_param_user, opt_param_user, req_param_inFile, opt_param_inFile):    
    
    # Constants
    printmd(&#x27;### &lt;br&gt;&lt;br/&gt; Settings for constants ###&#x27;) 
    printmd(&#x27;More information on these constants an be found [here](https://pyco2sys.readthedocs.io/en/latest/co2sys_nd/#settings). Default constants chosen based on [Jiang et al., 2022](https://www.frontiersin.org/articles/10.3389/fmars.2021.705638/full).&#x27;)
    #Widgets for the different constants
    phstr = widgets.Output()
    @phstr.capture()
    def constStrings1():
        printmd(&quot;&lt;br&gt;**Choose the pH scale:**&quot;)
        
    constStrings1()

    option_list=[&#x27;1. Total&#x27;,
                 &#x27;2. Seawater&#x27;,
                 &#x27;3. Free&#x27;,
                 &#x27;4. NBS, i.e. relative to NBS/NIST reference standards&#x27;]
    
    #PH Scale
    phscale=widgets.RadioButtons(
        options=option_list,  
        disabled=False,
        layout={&#x27;width&#x27;: &#x27;max-content&#x27;},
    )
    phscale.layout.margin=&#x27;0.5% 1% 3% 0%&#x27;
    #phscale.layout.width=&#x27;40%&#x27; 


    # Carbonic Acid Dissociation
    k1k2str = widgets.Output()
    @k1k2str.capture()
    def constStrings2():
        printmd(&quot;**Choose the set of equilibrium constant parameterisations to model carbonic acid dissociation:**&quot;)
    constStrings2()

    option_list=[&#x27;1. RRV93 (0 &lt; T &lt; 45 Â°C, 5 &lt; S &lt; 45, Total scale, artificial seawater).&#x27;,
                &#x27;2. GP89 (âˆ’1 &lt; T &lt; 40 Â°C, 10 &lt; S &lt; 50, Seawater scale, artificial seawater).&#x27;,
                &#x27;3. H73a and H73b refit by DM87 (2 &lt; T &lt; 35 Â°C, 20 &lt; S &lt; 40, Seawater scale, artificial seawater).&#x27;,
                &#x27;4. MCHP73 refit by DM87 (2 &lt; T &lt; 35 Â°C, 20 &lt; S &lt; 40, Seawater scale, real seawater).&#x27;,
                &#x27;5. H73a, H73b and MCHP73 refit by DM87(2 &lt; T &lt; 35 Â°C, 20 &lt; S &lt; 40, Seawater scale, real seawater)&#x27;,
                &#x27;6. MCHP73 aka &quot;GEOSECS&quot; (2 &lt; T &lt; 35 Â°C, 19 &lt; S &lt; 43, NBS scale, real seawater).&#x27;,
                &#x27;7. MCHP73 without certain species aka &quot;Peng&quot; (2 &lt; T &lt; 35 Â°C, 19 &lt; S &lt; 43, NBS scale, real seawater).&#x27;,
                &#x27;8. M79 (0 &lt; T &lt; 50 Â°C, S = 0, freshwater only).&#x27;,            
                &#x27;9. CW98 (2 &lt; T &lt; 30 Â°C, 0 &lt; S &lt; 40, NBS scale, real estuarine seawater).&#x27;,
                &#x27;10. LDK00 (2 &lt; T &lt; 35 Â°C, 19 &lt; S &lt; 43, Total scale, real seawater).&#x27;,
                &#x27;11. MM02 (0 &lt; T &lt; 45 Â°C, 5 &lt; S &lt; 42, Seawater scale, real seawater).&#x27;,
                &#x27;12. MPL02 (âˆ’1.6 &lt; T &lt; 35 Â°C, 34 &lt; S &lt; 37, Seawater scale, field measurements).&#x27;,
                &#x27;13. MGH06 (0 &lt; T &lt; 50 Â°C, 1 &lt; S &lt; 50, Seawater scale, real seawater).&#x27;,
                &#x27;14. M10 (0 &lt; T &lt; 50 Â°C, 1 &lt; S &lt; 50, Seawater scale, real seawater).&#x27;,
                &#x27;15. WMW14 (0 &lt; T &lt; 45 Â°C, 0 &lt; S &lt; 45, Seawater scale, real seawater).&#x27;,
                &#x27;16. SLH20 (âˆ’1.67 &lt; T &lt; 31.80 Â°C, 30.73 &lt; S &lt; 37.57, Total scale, field measurements).&#x27;,
                &#x27;17. SB21 (15 &lt; T &lt; 35 Â°C, 19.6 &lt; S &lt; 41, Total scale, real seawater).&#x27;]
    
    k1k2=widgets.RadioButtons(
        options=option_list,    
        value=&#x27;10. LDK00 (2 &lt; T &lt; 35 Â°C, 19 &lt; S &lt; 43, Total scale, real seawater).&#x27;,
        #rows=len(option_list),
        layout={&#x27;width&#x27;: &#x27;max-content&#x27;},
        disabled=False,
    )
    k1k2.layout.margin=&#x27;0.5% 1% 3% 0%&#x27;
    #k1k2.layout.width=&#x27;50%&#x27;
    #k1k2.layout.height=&#x27;100%&#x27;

    # Bisulfate ion dissociation 
    kso4str = widgets.Output()
    @kso4str.capture()
    def constStrings3():
        printmd(&quot;**Choose the equilibrium constant parameterisations to model bisulfate ion dissociation:**&quot;)
    constStrings3()

    option_list=[&#x27;1. D90a: Dickson (1990) J. Chem. Thermodyn.&#x27;,
                &#x27;2. KRCB77: Khoo et al. (1977) Anal. Chem.&#x27;,
                &#x27;3. WM13: Waters &amp; Millero (2013) Mar. Chem./ WMW14: Waters et al. (2014) Mar. Chem.&#x27;]
    
    kso4=widgets.RadioButtons(
        options=option_list,    
        value=&#x27;1. D90a: Dickson (1990) J. Chem. Thermodyn.&#x27;,
        layout={&#x27;width&#x27;: &#x27;max-content&#x27;},
        #description=&#x27;Parameter:&#x27;,
        disabled=False,
    )
    kso4.layout.margin=&#x27;0.5% 1% 3% 0%&#x27;
    #kso4.layout.width=&#x27;40%&#x27;

    # Total borate 
    bostr = widgets.Output()
    @bostr.capture()
    def constStrings4():
        printmd(&quot;**Choose which boron:salinity relationship to use to estimate total borate:**&quot;)
    constStrings4()

    option_list=[&#x27;1. U74: UppstrÃ¶m (1974) DeepSea Res.&#x27;,
                &#x27;2. LKB10: Lee et al. (2010) Geochim. Cosmochim. Acta&#x27;]
    
    bo=widgets.RadioButtons(
        options=option_list,    
        value=&#x27;2. LKB10: Lee et al. (2010) Geochim. Cosmochim. Acta&#x27;,
        layout={&#x27;width&#x27;: &#x27;max-content&#x27;},
        disabled=False,
    )
    bo.layout.margin=&#x27;0.5% 1% 3% 0%&#x27;
    # bo.layout.width=&#x27;40%&#x27;
    
    # hydrogen fluoride dissociation
    hfstr = widgets.Output()
    @hfstr.capture()
    def constStrings5():
        printmd(&quot;**Choose which which equilibrium constant parameterisation to use for hydrogen fluoride dissociation:**&quot;)
    constStrings5()

    option_list=[&#x27;1. DR79: Dickson &amp; Riley (1979) Mar. Chem.&#x27;,
                &#x27;2. PF87: Perez &amp; Fraga (1987) Mar. Chem.&#x27;]
    
    hf=widgets.RadioButtons(
        options=option_list,    
        value=&#x27;2. PF87: Perez &amp; Fraga (1987) Mar. Chem.&#x27;,
        layout={&#x27;width&#x27;: &#x27;max-content&#x27;},
        disabled=False,
    )
    hf.layout.margin=&#x27;0.5% 1% 3% 0%&#x27;
    # hf.layout.width=&#x27;40%&#x27; 

    # opt_gas_constant
    gcstr = widgets.Output()
    @gcstr.capture()
    def constStrings6():
        printmd(&quot;**Choose which value to use for the gas constant:**&quot;)
    constStrings6()
    option_list=[&#x27;1. DOEv2&#x27;,
                &#x27;2. DOEv3&#x27;,
                &#x27;3. 2018 CODATA&#x27;]
    
    gc=widgets.RadioButtons(
        options=option_list,    
        value=&#x27;3. 2018 CODATA&#x27;,
        layout={&#x27;width&#x27;: &#x27;max-content&#x27;},
        disabled=False,
    )
    gc.layout.margin=&#x27;0.5% 1% 3% 0%&#x27;
    # gc.layout.width=&#x27;40%&#x27; 
    
    #Continue button On-click function
    output = widgets.Output()
    @output.capture()
    def on_button_clicked(b):        
        runPyco2sys(df,req_param_user, opt_param_user, req_param_inFile, opt_param_inFile, phscale, k1k2, kso4, bo, hf,gc)

    # Button widget
    button2=widgets.Button(
    description=&#x27;Continue&#x27;,
    disabled=False,
    button_style=&#x27;&#x27;, # &#x27;success&#x27;, &#x27;info&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27; or &#x27;&#x27;
    tooltip=&#x27;Click me&#x27;,
    icon=&#x27;&#x27;
    )

    box2 = widgets.VBox([phstr,phscale, k1k2str, k1k2, kso4str, kso4, bostr, bo, hfstr, hf, gcstr,gc, button2])
    display(box2)

    button2.on_click(on_button_clicked)
    display(output)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="Cp8Wd_Sb6i78tqcGzyB3Y" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="T2jbzbtCwP" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def runPyco2sys(df,req_param_user, opt_param_user, req_param_inFile, opt_param_inFile, phscale, k1k2, kso4, bo, hf,gc):


    #Build the argument list for pyco2sys to ingest
    #The argument names are defined in the PyCO2 sys documentation.
    kwargs={}
   

    #KEY PARAMETERS
    
    # pyco2sys labels the two key parameters chosen as par 1 and par 2. &#x27;par1check&#x27; checks if par1 has yet been assigned, otherwise it sets a key parameter to par 2
    par1check=&quot;False&quot;
    par2check=&quot;False&quot;

    
    #Check if the parameter was chosen by the user, or if it was automatically selected (only two parameters were in the file). In that case the variable would not be in &#x27;req_param_user&#x27; from the widget.
    #If the varibale is to be used in the calculation, then get the data from the input file (saved as the data frame df)
    #The variable is then added to the arguments for pyco2sys
    
    substrings=[&#x27;alkalinity&#x27;,&#x27;Dissolved inorganic carbon&#x27;,&#x27;pH&#x27;,&#x27;Partial pressure of carbon dioxide&#x27;, &#x27;Fugacity of carbon dioxide&#x27;,&#x27;Carbonate ion concentration&#x27;, &#x27;Bicarbonate Ion&#x27;]
    standardizedNames=[&#x27;TotAlk_l_um_l&#x27;,&#x27;DIC_um_l&#x27;,&#x27;pH&#x27;,&#x27;pCO2&#x27;,&#x27;fCO2&#x27;,&#x27;CO232&#x27;,&#x27;biCO2&#x27;]
    types=[1,2,3,4,5,6,7]   #These are the different types according to pyco2sys documentation 
    
    
    for name, substr, t in zip(standardizedNames, substrings, types):           # Loop through the substrings and the standardized names  
        if par1check==&quot;False&quot; or par2check==&quot;False&quot;:                            #Check if either par1 or par2 is false. We need at least two key paramaters (par1 and par2 represent these two parameters)
            if any(substr in string for string in req_param_inFile):            #If it is in the input file
                if len(req_param_inFile)==2:                                    #If it is one of only two key variables in the input file (here it would not be in &#x27;req_param_user.value&#x27; as it would be automatically selected- no widget used)
   
                    if par1check==&quot;True&quot;:        
                        kwargs[&#x27;par2&#x27;]=df[name].to_numpy(dtype=float)            #Get the data using the standardized name from the data frame (input file)
                        kwargs[&#x27;par2_type&#x27;]=t
                        par2check=&quot;True&quot;
                    else:
                        kwargs[&#x27;par1&#x27;]=df[name].to_numpy(dtype=float)             
                        kwargs[&#x27;par1_type&#x27;]=t
                        par1check=&quot;True&quot;

                elif len(req_param_inFile)&gt;2:                                    # If there are more than two key parameters in the input file
                    if any(substr in string for string in req_param_user.value): #If there are more than two key variables in the file, then check if the user actually selected this varibale
                        if par1check==&quot;True&quot;:        
                            kwargs[&#x27;par2&#x27;]=df[name].to_numpy(dtype=float)          
                            kwargs[&#x27;par2_type&#x27;]=t
                            par2check=&quot;True&quot;
                        else:
                            kwargs[&#x27;par1&#x27;]=df[name].to_numpy(dtype=float)          
                            kwargs[&#x27;par1_type&#x27;]=t
                            par1check=&quot;True&quot;



                            
    # OPTIONAL PARAMETERS
    
    substrings_opt=[&#x27;Silicate&#x27;,&#x27;Phosphate&#x27;,&#x27;Ammonia&#x27;,&#x27;Sulfide&#x27; ]
    standardizedNames=[&#x27;SiOx_um_l&#x27;,&#x27;PO4_Filt_um_l&#x27;,&#x27;Ammonia&#x27;,&#x27;Sulfide&#x27;]
    pyco2sysNames=[&#x27;total_silicate&#x27;,&#x27;total_phosphate&#x27;,&#x27;total_phosphate&#x27;,&#x27;total_sulfide&#x27;]  # Names that pyco2sys expects in the argument list
    
    
    if len(opt_param_inFile)&gt;0:  # if there is at least one optional paramter in the input file.        
        for name, substr, pName in zip(standardizedNames, substrings_opt, pyco2sysNames):     
            if any(substr in string for string in opt_param_user.value):  # If the optional parameter was chosen by the user
                kwargs[pName]=df[name].to_numpy(dtype=float)              # Get the data using the standardized name
        

        
    # MANDATORY  PARAMETERS

    # Also check if the user wanted to use any other output temperature and pressure in the calculations.
    # If they did not, the temp_out and press_out would be &#x27;nan&#x27;
    
    #Set the output temperature and pressure to nan
    Temperature_out=float(&#x27;nan&#x27;)
    Pressure_out=float(&#x27;nan&#x27;)
    
    Temperature=df[&#x27;CTDTmp90&#x27;].to_numpy(dtype=float)
    kwargs[&#x27;temperature&#x27;]=Temperature
    #if np.isnan(Temperature_out)==False:    
    kwargs[&#x27;temperature_out&#x27;]=Temperature_out

    Pressure=df[&#x27;Pres_Z&#x27;].to_numpy(dtype=float)
    kwargs[&#x27;pressure&#x27;]=Pressure   
    #if np.isnan(Pressure_out)==False:    
    kwargs[&#x27;temperature_out&#x27;]=Pressure_out   

    Salinity=df[&#x27;P_sal_CTD&#x27;].to_numpy(dtype=float)
    kwargs[&#x27;salinity&#x27;]=Salinity   



    #Get the values of the widget selections for the different CONSTANTS. All parameters are selected by default.
    
    k1k2Value=k1k2.value
    kso4Value=kso4.value
    boValue=bo.value
    hfValue=hf.value
    phscaleValue=phscale.value
    gcValue=gc.value

    kso4Value_temp=kso4Value[:2]
    boValue_temp=boValue[:2]
    hfValue_temp=hfValue[:2]
    k1k2Value_temp=k1k2Value[:2]
    phscaleValue_temp=phscaleValue[:2]
    gcValue_temp=gcValue[:2]
        
    if &#x27;.&#x27; in kso4Value_temp:      
        kso4Value_temp=kso4Value_temp[:1]
    
    if &#x27;.&#x27; in boValue_temp:       
        boValue_temp=boValue_temp[:1]       

    if &#x27;.&#x27; in hfValue_temp:       
        hfValue_temp=hfValue_temp[:1]       
        
    if &#x27;.&#x27; in k1k2Value_temp:       
        k1k2Value_temp=k1k2Value_temp[:1]
              
    if &#x27;.&#x27; in phscaleValue_temp:   
        phscaleValue_temp=phscaleValue_temp[:1]
        
    if &#x27;.&#x27; in gcValue_temp:
        gcValue_temp=gcValue_temp[:1]
    
    k1k2Value=int(k1k2Value_temp)
    kso4Value=int(kso4Value_temp)
    boValue=int(boValue_temp)
    hfValue=int(hfValue_temp)
    phscaleValue=int(phscaleValue_temp)
    gcValue=int(gcValue_temp)
        
    #Add them as arguments for pyco2sys
    kwargs[&#x27;opt_k_carbonic&#x27;]=k1k2Value
    kwargs[&#x27;opt_k_bisulfate&#x27;]=kso4Value
    kwargs[&#x27;opt_total_borate&#x27;]=boValue
    kwargs[&#x27;opt_k_fluoride&#x27;]=hfValue
    kwargs[&#x27;opt_gas_constant&#x27;]=gcValue


    # Import PyCO2SYS
    import PyCO2SYS as pyco2

    # Run pyCO2SYS!
    output_dict = pyco2.sys(**kwargs)

    
    Output(df,output_dict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="M3ovHUwbAkMX33uCG5VXK" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="DCPiZEU1Ix" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def Output(df,output_dict):
    
#     ## Added to make the &quot;continue button&quot; to continue the process into the Sea Ice Concentration retrieval: 
    def on_button_sic(b):
        continue_sic()

    outsic=widgets.Output()
    @outsic.capture()
    def continue_sic():
        ccadi_uc3_mapping() # sea ice concentration processing

    ###########################################
    
    
    #The dictionary output_dict is uneven. Some elements are just a single int, string or float. The length of &#x27;par1&#x27; will always be the longest length (it holds the first of the two key parameters from the input file)
    #For the values in the dictionary that are not single values, they are arrays. 
    #To be able to create even data frames, we need to seperate the values in the array and create a list.
    #Otherise, the array is saved as one value for each key, instad of a list of multiple values.
    
    
    longlength=len(output_dict[&#x27;par1&#x27;])
    newlist=[]

    for val in output_dict.values():

        #if value is a single integer&quot;
        if isinstance(val, int):
            list0=[val] * longlength
            newlist.append(list0)

        elif isinstance(val, str):
            list1=[val] * longlength
            newlist.append(list1)

        elif isinstance(val, float):
            list2=[val] * longlength
            newlist.append(list2)
        else:
            arr=val
            list3 = arr.tolist()
            newlist.append(list3)
            
            
    #Creae a new dict that has keys associated with a list of values, all of the same length.            
    newdict={}
    i=0
    for key in output_dict.keys():
        newdict[key]=newlist[i]
        i=i+1


    #Create a new dataframe and save as csv.
    output_df=pd.DataFrame.from_dict(newdict)

    #Merge this resulting data frame with extra variables from the input file that were not used in calculations
    cols_to_use = df.columns.difference(output_df.columns)   #variales that are different from those in output file
    input_subset=df[cols_to_use]
    merged_df = pd.concat([output_df,input_subset] , axis=1)  #Merged dataframe

        
    # Organize data frame so that specific varibales are at the front
    front_metadata=[&#x27;project name&#x27;,&#x27;platform name&#x27;,&#x27;Cruise&#x27;, &#x27;Station&#x27;,&#x27;sample date&#x27;,&#x27;TIME&#x27;,&#x27;latitude&#x27;,&#x27;longitude&#x27;,&#x27;sample depth&#x27;,&#x27;Cast&#x27;,&#x27;Bottle&#x27;]
    
    #Loop through the list of metadata variables that should be at the front
    col_position=-1
    for var in front_metadata: 
        for col in merged_df.columns:                                  # Loop through all the columns in dataframe
            stripped_string = re.sub(&quot;[^0-9a-zA-Z]+&quot;, &quot; &quot;,col)         # Strip the column headers of all non- laphanumeric characters
            if var.lower() in stripped_string.lower():                 # Check for column name regardless of case
                popped_col_data=merged_df.pop(col)                     # Pop the column from daat frame
                col_position=col_position+1                            # Find the next front position
                merged_df.insert(col_position, col, popped_col_data)   # Place variable at position

    front_data=[&#x27;saturation_aragonite&#x27;, &#x27;saturation_aragonite_out&#x27;,&#x27;saturation_calcite&#x27;,&#x27;saturation_calcite_out&#x27;,&#x27;pCO2&#x27;,&#x27;fCO2&#x27;,&#x27;bicarbonate&#x27;,&#x27;pH_total&#x27;]

    #Loop through the list of calculated carbonate chemistry variables that should be at the front
    for var in front_data: 
        for col in merged_df.columns:                                  # Loop through all the columns in dataframe
            if col==var:                 
                popped_col_data=merged_df.pop(col)                     # Pop the column from daat frame
                col_position=col_position+1                            # Find the next front position
                merged_df.insert(col_position, col, popped_col_data)   # Place variable at position
    
    
    #Remove par1, par2, par1 and par2 types- added by pyco2, not needed by user 
    merged_df.pop(&#x27;par1&#x27;)
    merged_df.pop(&#x27;par2&#x27;)
    merged_df.pop(&#x27;par1_type&#x27;)
    merged_df.pop(&#x27;par2_type&#x27;)

    #Remove duplicate columns from final data frame
    duplicateColumnNames = list()

    for x in range(merged_df.shape[1]):                   # Iterate over all the columns in dataframe
        col_name1= merged_df.columns[x]                   # Select column at xth index.

        for y in range(x + 1, merged_df.shape[1]):        # Iterate over all the columns in DataFrame from (x+1)th index till end
            col_name2= merged_df.columns[y]
            
            if col_name1.lower()==col_name2.lower():      # Check if column names are the same regardless of case
                duplicateColumnNames.append(col_name1)
                continue
                
            if &#x27;.1&#x27; in col_name1:                         # Check if there is a duplicate (same case), pandas will save this with a .1 at the end of the duplicated variable
                col_name1_stripped=col_name1.strip(&#x27;.1&#x27;)  # Remove .1 and check again for equality 
                if col_name1_stripped.lower()==col_name2.lower():
                    duplicateColumnNames.append(col_name1)
                    continue
                
            if &#x27;.1&#x27; in col_name2:
                col_name2_stripped=col_name2.strip(&#x27;.1&#x27;)
                if col_name1.lower()==col_name2_stripped.lower():
                     duplicateColumnNames.append(col_name2)
                        
    merged_df = merged_df.drop(columns=duplicateColumnNames)  #Drop all duplicates
    merged_df=merged_df.dropna(axis=1,how=&#x27;all&#x27;)              #Drop all empty columns

    # OUTPUT FILE----------------------------------------------------------------------
    if os.path.isfile(os.path.join(&quot;2016_int_btl_csv&quot;, &quot;merged_btl_nutrient_pyco2sys.csv&quot;))==True:  
        os.remove(os.path.join(&quot;2016_int_btl_csv&quot;, &quot;merged_btl_nutrient_pyco2sys.csv&quot;))
    merged_df.to_csv(os.path.join(&quot;2016_int_btl_csv&quot;, &quot;merged_btl_nutrient_pyco2sys.csv&quot;), index=False)   
    # OUTPUT FILE----------------------------------------------------------------------

    
    printmd(&#x27;**&lt;br /&gt;PCO2sys ran successfully! Output file is saved as merged_btl_nutrient_pyco2sys.csv**&#x27;)
    printmd(&quot;&lt;br /&gt;**Retrieving ice concentration now...**&quot;)
 
    # add the &quot;continue button&quot; on the GUI ######################################
    gridwindow={}
    vbox_widgets = []
    gridwindow[&#x27;grid&#x27;] = widgets.GridspecLayout(1,1)

    continue_button2=widgets.Button(
        description=&#x27;Continue&#x27;,
        disabled=False,
        button_style=&#x27;&#x27;, 
        tooltip=&#x27;Click me&#x27;,
        icon=&#x27;&#x27;
        )
    gridwindow[&#x27;to_sic&#x27;] =  widgets.HBox(children=[continue_button2])
    vbox_widgets.append(gridwindow[&#x27;to_sic&#x27;])
    gridwindow[&#x27;grid&#x27;][0, 0] = widgets.VBox(children=vbox_widgets)
    display(gridwindow[&#x27;grid&#x27;])
    continue_button2.on_click(on_button_sic)
    display(outsic)
    ##################################################

    </code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="bdGq81v3dTK62lgGHdaDP" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="MiajehcXnS" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">L = mlp.Lock()
class addSeaIceConcentration:
    def __init__(self, inputfile):
        self.inputfile = inputfile

    def createShapefile(self, df, output_shp, time_header, prglabel):
        &#x27;&#x27;&#x27; This function creates a shapefile from the geographical locations inside the input CSV file.
            The coordinate system used for the output shapetile is the World Geodetic System (WGS) 1984.
            Both Latitude and Longitude are in decimal degrees&#x27;&#x27;&#x27;
        prglabel.value = &#x27;Creating the final shapefile...&#x27;
        shpfile = os.path.join(os.path.dirname(self.inputfile), output_shp, output_shp + &#x27;.shp&#x27;)
        if not os.path.exists(os.path.join(os.path.dirname(self.inputfile), output_shp)):
            os.makedirs(os.path.join(os.path.dirname(self.inputfile), output_shp))
        driver = ogr.GetDriverByName(&quot;ESRI Shapefile&quot;)
        if os.path.exists(shpfile):
            driver.DeleteDataSource(shpfile)
        ds = driver.CreateDataSource(shpfile)
        spref = osr.SpatialReference()
        spref.ImportFromEPSG(4326)
        layer = ds.CreateLayer(&#x27;StationsLocations&#x27;, spref, ogr.wkbPoint)
        # create field to the layer
        for c in df.columns:
            u = list(df[c])
            vint = [i for i in u if isinstance(i, int)]
            vfloat = [i for i in u if isinstance(i, float)]
            if c.__contains__(time_header):
                layer.CreateField(ogr.FieldDefn(time_header, ogr.OFTDateTime))
            elif c.__contains__(&#x27;CIS_dates&#x27;):
                layer.CreateField(ogr.FieldDefn(&#x27;CIS_dates&#x27;, ogr.OFTDateTime))
            elif c.__contains__(&#x27;Time&#x27;):
                fieldname = ogr.FieldDefn(&#x27;Time UTC&#x27;, ogr.OFTString)
                fieldname.SetWidth(20)
                layer.CreateField(fieldname)
            elif len(u) == len(vint):
                df[c] = df[c].astype(float)
                ##############################################
                fieldname = ogr.FieldDefn(c, ogr.OFTInteger)
                fieldname.SetPrecision(0)
                layer.CreateField(fieldname)
            elif len(u) == len(vfloat):
                fieldname = ogr.FieldDefn(c, ogr.OFTReal)
                fieldname.SetPrecision(6)
                layer.CreateField(fieldname)
            else:
                df[c].astype(str)
                fieldname = ogr.FieldDefn(c, ogr.OFTString)
                fieldname.SetWidth(30)
                layer.CreateField(fieldname)

        c_fid = 0
        ld = layer.GetLayerDefn()
        lon = [i for i in df.columns if i.__contains__(&#x27;longitude&#x27;)].pop()
        lat = [i for i in df.columns if i.__contains__(&#x27;latitude&#x27;)].pop()
        for i in df.index:
            # create new point object
            point = ogr.Geometry(ogr.wkbPoint)
            point.AddPoint(float(df[lon].values[i]), float(df[lat].values[i]))
            # create new feature
            featureDfn = layer.GetLayerDefn()
            feature = ogr.Feature(featureDfn)
            feature.SetGeometry(point)
            for k in range(0, df.columns.__len__()):
                fieldName = ld.GetFieldDefn(k).GetName()
                feature.SetField(fieldName, df[df.columns[k]].values[i])
            c_fid += 1
            # add the new feature to the new layer
            layer.CreateFeature(feature)
        del layer, ds, df
        return 0

    def extractFromUniBremenAMSR2(self, prm):
        &#x27;&#x27;&#x27; Sea Ice Concentration (SIC) from Bremen University are downloaded. The SIC located at each geographical
        coordinate indicated in the input csv file are extracted and then added as an extra-column to the csv file. &#x27;&#x27;&#x27;
        L.acquire()
        ddate = pd.to_datetime(prm[0])
        dlat = prm[1]
        dlon = prm[2]
        q = prm[3]
        m = datetime.strftime(ddate, &#x27;%b&#x27;).lower()  # extract the month in lowercase charachter
        y = datetime.strftime(ddate, &#x27;%Y&#x27;)  # extract the year
        with tempfile.TemporaryDirectory() as tmpDir:
            url = r&#x27;https://seaice.uni-bremen.de/data/amsr2/asi_daygrid_swath/n6250/{0}/{1}/Arctic/asi-AMSR2-n6250-{2}-v5.4.tif&#x27;.format(
                y, m, datetime.strftime(ddate, &#x27;%Y%m%d&#x27;))
            if not os.path.exists(os.path.join(os.path.join(os.path.dirname(self.inputfile), &#x27;BU_rasters&#x27;),
                                               &#x27;asi-AMSR2_{0}.tif&#x27;.format(
                                                   datetime.strftime(ddate, &#x27;%Y%m%d&#x27;)))):
                urllib.request.urlretrieve(url, os.path.join(tmpDir, &#x27;asi-AMSR2.tif&#x27;))
                if (q == &#x27;Y&#x27;):
                    shutil.copy2(os.path.join(tmpDir, &#x27;asi-AMSR2.tif&#x27;),
                                 os.path.join(os.path.join(os.path.dirname(self.inputfile), &#x27;BU_rasters&#x27;),
                                              &#x27;asi-AMSR2_{0}.tif&#x27;.format(
                                                  datetime.strftime(ddate, &#x27;%Y%m%d&#x27;))))
                    src_filename = os.path.join(os.path.join(os.path.dirname(self.inputfile), &#x27;BU_rasters&#x27;),
                                                &#x27;asi-AMSR2_{0}.tif&#x27;.format(
                                                    datetime.strftime(ddate, &#x27;%Y%m%d&#x27;)))
                else:
                    src_filename = os.path.join(tmpDir, &#x27;asi-AMSR2.tif&#x27;)
            else:
                src_filename = os.path.join(os.path.join(os.path.dirname(self.inputfile), &#x27;BU_rasters&#x27;),
                                            &#x27;asi-AMSR2_{0}.tif&#x27;.format(
                                                datetime.strftime(ddate, &#x27;%Y%m%d&#x27;)))
            try:
                outval = self.pointExtract(src_filename, dlat, dlon)
                prm[4].put(prm[5])
            except:
                outval = np.nan
                prm[4].put(prm[5])
                pass
        L.release()
        return ([float(outval), datetime.strftime(ddate.to_pydatetime(), &#x27;%Y-%m-%d&#x27;)])

    def extractFromCSI(self, prm):
        &#x27;&#x27;&#x27;For each acquisition date in the csv file, differences are calculated between each one of them and each one included
        in the CIS tar files. Then the tar file corresponding the minimum difference is choosen for the extraction
        of the Sea Ice Concentration. &#x27;&#x27;&#x27;
        L.acquire()  # this is needed to lock each process to let them running separately without writing in a same variable at the same time
        ddate = pd.to_datetime(prm[0])  # Acquisition date from the csv file.
        dlat = prm[1]
        dlon = prm[2]
        fcis = prm[3]
        CISRaster = prm[4]

        CIS_acquisition_times = [datetime.strptime(i.split(&#x27;_&#x27;)[2], &#x27;%Y%m%dT%H%MZ&#x27;).date() for i in fcis]
        wq = np.array(CIS_acquisition_times)
        CIS_acquisition_times = list(np.unique(wq))
        csv_acquisition_time = datetime.strftime(ddate, &#x27;%Y%m%dT%H%M%S&#x27;)
        sample_date = datetime.strptime(csv_acquisition_time, &#x27;%Y%m%dT%H%M%S&#x27;).date()
        dt_abs = [abs(sample_date - each_date) for each_date in CIS_acquisition_times]
        closest_date = CIS_acquisition_times[dt_abs.index(min(dt_abs))]
        outraster = os.path.join(CISRaster, [i for i in fcis if i.__contains__(datetime.strftime(closest_date, &#x27;%Y%m%d&#x27;))][0][:-4] + &#x27;.tif&#x27;)
        intval = self.pointExtract(outraster, dlat, dlon)
        outval = intval[0][0]
        prm[5].put(prm[6])
        L.release()  # this releases the locked process
        return ([float(outval), datetime.strftime(closest_date, &#x27;%Y-%m-%d&#x27;)])
#         return ([float(outval), datetime.strftime(CIS_acquisition_times[s[0][0]], &#x27;%Y-%m-%d&#x27;)])

    def selectCISFiles(self, prm):
        &#x27;&#x27;&#x27;This function select the filenames from the CIS acquired at the nearest time as each one of the within the
        input csv file. The output list of files will be used to download them. &#x27;&#x27;&#x27;
        L.acquire()
        ddate = pd.to_datetime(prm[0])
        fcislist = prm[3]
        CIS_acquisition_times = [datetime.strptime(i.split(&#x27;_&#x27;)[2], &#x27;%Y%m%dT%H%MZ&#x27;).date() for i in fcislist]
        wq = np.array(CIS_acquisition_times)
        CIS_acquisition_times = list(np.unique(wq))
        u = datetime.strftime(ddate, &#x27;%Y%m%dT%H%M%S&#x27;) # sample date
        sample_date = datetime.strptime(u, &#x27;%Y%m%dT%H%M%S&#x27;).date()
        dt_abs = [abs(sample_date - each_date) for each_date in CIS_acquisition_times]
        closest_date = CIS_acquisition_times[dt_abs.index(min(dt_abs))]
        prm[5].put(prm[6])
        L.release()
        return [i for i in fcislist if i.__contains__(datetime.strftime(closest_date, &#x27;%Y%m%d&#x27;))][0]

    def binaryretrieve(self, j):
        &#x27;&#x27;&#x27;The connection to the FTP server of the Canadian Ice Service is done in this function.
        All the spatial coordinate are assumed to be within the region Eastern_Arctic and in the same year 2016
        as the case of the GreenEdge data. &#x27;&#x27;&#x27;
        L.acquire()
        i = j[0]
        shp_for_UC3 = j[1]
        hostname = &#x27;sidads.colorado.edu&#x27;
        ftp = FTP(hostname)
        ftp.login(user=&#x27;anonymous&#x27;, passwd=&#x27;&#x27;)
        ## This should be changed to be dynamically change depending on the region (here: Eastern_Arctic) and the year.
        # The User Guide from the Canadian Ice Service (https://nsidc.org/data/G02171/versions/1?qt-data_set_tabs=3#qt-data_set_tabs) discribe all the possible region names
        ftp.cwd(&#x27;/pub/DATASETS/NOAA/G02171/Eastern_Arctic/2016/&#x27;) 
        if not os.path.exists(os.path.join(shp_for_UC3, i)):
            with open(os.path.join(shp_for_UC3, i), &#x27;wb&#x27;) as localfile:
                ftp.retrbinary(&#x27;RETR &#x27; + i, localfile.write, 1024)
        ftp.quit()
        j[2].put(j[0])
        L.release()
        return 0

    def fetchTarFromCIS(self, tarfile, shp_for_UC3, CISRaster, prglabel, pr, pStatus):
        &#x27;&#x27;&#x27; This function manage the file retrieval from the CIS and then call to another function to do the vector
        shapefiles into rasters. &#x27;&#x27;&#x27;

        if not os.path.exists(shp_for_UC3):
            os.makedirs(shp_for_UC3)
        &#x27;&#x27;&#x27;For now, we assume all the data in the csv file were acquired in the same year (2016) and from
        the same region (Eastern_Arctic) as the case of the GreenEdge data.&#x27;&#x27;&#x27;
        pool = mlp.Pool(processes=mlp.cpu_count()-2)
        m = Manager()
        queue = m.Queue()
        tarfilelist = [[i, shp_for_UC3, queue] for i in tarfile]
        s = pool.map_async(self.binaryretrieve, tarfilelist)
        ##
        while True:
            if s.ready():
                break
            else:
                c1 = int(queue.qsize() * 100 / len(tarfilelist))
                pr.value=c1
                prglabel.value = &#x27;Fetching files from the CIS server...&#x27;
                pStatus.value = f&#x27;{pr.value}%&#x27;
        ##
        del pool, s, queue, m
        # Start a new progressbar for the shapefile converstion
        m = Manager()
        queue = m.Queue()
        pr.value=0
        prglabel.value = &#x27;Converting shapefiles into raster files...&#x27;
        pStatus.value = f&#x27;{pr.value}%&#x27;
        ###################################################################
        for f in tarfile:
            &#x27;&#x27;&#x27;Here the *.shp file have already been extracted from the *.tar file, 
            so we only need to point to it as shp_filename&#x27;&#x27;&#x27;
            shutil.unpack_archive(os.path.join(shp_for_UC3, f), shp_for_UC3, f[-3:])
            shp_filename = os.path.join(shp_for_UC3, f[:-4] + &#x27;.shp&#x27;)
            outraster = os.path.join(CISRaster, f[:-4] + &#x27;.tif&#x27;)
            if not os.path.exists(outraster):
                self.makeRasterFromSHP(shp_filename, outraster, 100)
            queue.put(1)
            c1 = int(queue.qsize() * 100 / len(tarfilelist))
            pr.value=c1
            pStatus.value = f&#x27;{pr.value}%&#x27;
        del m, queue
        return 0


    def makeRasterFromSHP(self, shp_filename, outraster, pxlsize):
        &#x27;&#x27;&#x27; This function handle the transformation of the vector shapefile format into rasters format.
        The ogr python binding package is used to read the vector shepefile before their transfmation into raster.
         Here only the Field CT holding the Sea Ice Concentration data are rasterized.
         If needed, other Field amoung all of those included in the shapefile can be added as an additional band
         into the output raster. &#x27;&#x27;&#x27;
        shpfile = ogr.Open(shp_filename)
        layer = shpfile.GetLayer()
        xmin, xmax, ymin, ymax = layer.GetExtent()
        cols = int((xmax - xmin) / pxlsize)
        rows = int((ymax - ymin) / pxlsize)
        rdrive = gdal.GetDriverByName(&#x27;GTiff&#x27;)
        ds = rdrive.Create(outraster, cols, rows, 1, gdal.GDT_Byte)
        ds.SetGeoTransform([xmin, pxlsize, 0, ymax, 0, -pxlsize])
        gdal.RasterizeLayer(ds, [1], layer, options=[&#x27;ATTRIBUTE=CT&#x27;])
        ds.SetProjection(layer.GetSpatialRef().ExportToPrettyWkt())
        ds.GetRasterBand(1).SetNoDataValue(0)
        del ds, rdrive, shpfile, layer
        return 0

    def pointExtract(self, src_filename, dlat, dlon):
        &#x27;&#x27;&#x27; The extraction process is handled inside this function.
        The GDAL python binding package is used here to read the raster files needed for the extraction.
        The pyproj package is used to bring the geographical coordinates from the input csv to match the spatial
         coordinate system of the rasters in order to make the extraction of the right collocated pixel with the csv data. &#x27;&#x27;&#x27;
        src_ds = gdal.Open(src_filename)
        gt = src_ds.GetGeoTransform()
        band = src_ds.GetRasterBand(1)
        proj = osr.SpatialReference(wkt=src_ds.GetProjection())
        #####
        wgs84 = pyproj.CRS(&quot;EPSG:4326&quot;)
        rstProj = pyproj.CRS(proj.ExportToProj4())
        #####
        point = ogr.Geometry(ogr.wkbPoint)
        point.AddPoint(float(dlat), float(dlon))  # to make sure the corrdinates are not in string format
        mx, my = pyproj.Transformer.from_proj(wgs84, rstProj).transform(point.GetX(), point.GetY())
        px = int((mx - gt[0]) / gt[1])  # x pixel
        py = int((my - gt[3]) / gt[5])  # y pixel
        intval = band.ReadAsArray(px, py, 1, 1)
        del band, src_ds, point, proj, gt, mx, my, px, py
        return intval

    def getCISTarFileList(self, dlist, prglabel, pr, pStatus):
        &#x27;&#x27;&#x27; This function extract the file list needed for the extraction. It uses the acquisition year
        in the input csv file to locate the same year used in the FTP data endpoint in order to select the
        files to be downloaded. &#x27;&#x27;&#x27;
        dl = pd.to_datetime(dlist)
        csv_year = [datetime.strftime(s, &#x27;%Y&#x27;) for s in dl]
        csv_year = np.unique(csv_year)
        fcis_gen = []
        fcis = []
        m = Manager()
        queue = m.Queue()
        for y in csv_year:
            hostname = &#x27;sidads.colorado.edu&#x27;
            ftp = FTP(hostname)
            ftp.login(user=&#x27;anonymous&#x27;, passwd=&#x27;&#x27;)
            &#x27;&#x27;&#x27; There is more regions to be considered. Here the region Easter_Arctic is directly selected. &#x27;&#x27;&#x27;
            # TODO: Find a way to make automatic selection of the region of interest regarding the spatial extent of coordinate in the csv file used
            ftp.cwd(&#x27;/pub/DATASETS/NOAA/G02171/Eastern_Arctic/{0}/&#x27;.format(y))
            files = ftp.nlst()  # This extract all the files within the folder named with the YEAR in.
            ftp.quit()
            fcis_gen.append([i for i in files if i.__contains__(&#x27;cis&#x27;)])
        for i in fcis_gen:
            fcis = fcis + i
            queue.put(i)
            p = int(queue.qsize()*100/len(fcis_gen))
            pr.value=p
            prglabel.value = &#x27;Building file list...&#x27;
            pStatus.value = f&#x27;{pr.value}%&#x27;
        del fcis_gen, m, queue
        return fcis

    def ExtractionPixelValues(self, param_to_extract, q, rstsource, prglabel, pr, pStatus):
        &#x27;&#x27;&#x27; * inputfile: Comma Separated Value (CSV) file with a header containning Date, Latitude, and Longitude.
            * param_to_extract: name of the parameter to be extracted from the raster. This will become the name of
            the new column that will be added to the initial csv file. Here it is about Sea_Ice_Concentration.
            The format of the Date in the csv file should be mm/dd/yyyy.
            The Latitude and Longitude Should be in full decimal format and their values are in the range [-180, 180].

            * The Extraction Process is don using parallel computing to accelerate the process. Parallel processing is
            very usefull here as the Extraction of the data coresponding to each rows are independent from each other.
        &#x27;&#x27;&#x27;

        outfile = os.path.join(os.path.split(self.inputfile)[0],
                               os.path.split(self.inputfile)[1][:-4] + &#x27;_{0}_{1}.csv&#x27;.format(param_to_extract,
                                                                                             rstsource))
        if os.path.exists(outfile):
            os.remove(outfile)
        df = pd.read_csv(self.inputfile, header=0, sep=&#x27;,&#x27;, parse_dates=True, skiprows=[1])
        time_header=[i for i in df.columns if
                     ((i.__contains__(&#x27;Date&#x27;)) or (i.__contains__(&#x27;date&#x27;)) or
                      (i.__contains__(&#x27;Time&#x27;)) or (i.__contains__(&#x27;time&#x27;)))].pop()
        if rstsource == &#x27;BU&#x27;:
            m = Manager()
            queue = m.Queue()
            lon = [i for i in df.columns if i.__contains__(&#x27;longitude&#x27;)].pop()
            lat = [i for i in df.columns if i.__contains__(&#x27;latitude&#x27;)].pop()
            p = [[df[time_header][i], df[lat][i], df[lon][i], q, queue, i] for i in df.index]
            if q == &#x27;Y&#x27;:
                if not os.path.exists(os.path.join(os.path.dirname(self.inputfile), &#x27;BU_rasters&#x27;)):
                    os.makedirs(os.path.join(os.path.dirname(self.inputfile), &#x27;BU_rasters&#x27;))
            pool = mlp.Pool(mlp.cpu_count() - 2)
            s = pool.map_async(self.extractFromUniBremenAMSR2, p)
            ##
            while True:
                if s.ready():
                    break
                else:
                    c1=int(queue.qsize()*100/len(p))
                    pr.value=c1 
                    pStatus.value = f&#x27;{pr.value}%&#x27;
            print(queue.qsize())
            ##
            a = np.array(s.get())
            del s
            b = np.transpose(a)
            df[param_to_extract] = b[0]
            df[time_header] = b[1]
            del pool, m, queue
        else:
            CISRaster = os.path.join(os.path.dirname(self.inputfile), &#x27;CISraster&#x27;)
            if not os.path.exists(CISRaster):
                os.makedirs(CISRaster)
            &#x27;&#x27;&#x27; Retrieval from the CIS server of filename list corresponding to each dataset in the csv file&#x27;&#x27;&#x27;
            fcis = self.getCISTarFileList(df[time_header], prglabel, pr, pStatus)
            m = Manager()
            queue = m.Queue()
            pr.value=0
            &#x27;&#x27;&#x27; Selection of each shapefile with a closest acquisition time to each dataset of the csv file. &#x27;&#x27;&#x27;
            lon = [i for i in df.columns if i.__contains__(&#x27;longitude&#x27;)].pop()
            lat = [i for i in df.columns if i.__contains__(&#x27;latitude&#x27;)].pop()
            p = [[df[time_header][i], df[lat][i], df[lon][i], fcis, CISRaster, queue, i] for i in df.index]
            pool = mlp.Pool(mlp.cpu_count() - 2)
            imglist = pool.map_async(self.selectCISFiles, p)
            prglabel.value = &#x27;Selecting CIS file...&#x27;
            while True:
                if imglist.ready():
                    break
                else:
                    c1=int(queue.qsize()*100/len(p))
                    pr.value=c1
                    pStatus.value = f&#x27;{pr.value}%&#x27;
            imgarray0 = np.array(imglist.get())
            imgarray1 = np.unique(imgarray0)
            imglist0 = list(imgarray1)
            CIS_shp = os.path.join(os.path.dirname(self.inputfile), &#x27;CIS_shp&#x27;)
            if not os.path.exists(CIS_shp):
                os.makedirs(CIS_shp)
            del imgarray0, imgarray1, pool, m, queue
            &#x27;&#x27;&#x27;Fetching the files from the remote server&#x27;&#x27;&#x27;
            self.fetchTarFromCIS(imglist0, CIS_shp, CISRaster, prglabel, pr, pStatus)
            pool = mlp.Pool(mlp.cpu_count() - 2)
            m = Manager()
            queue = m.Queue()
            p = [[df[time_header][i], df[lat][i], df[lon][i], fcis, CISRaster, queue, i] for i in df.index]
            s = pool.map_async(self.extractFromCSI, p)
            ##
            while True:
                if s.ready():
                    break
                else:
                    c1=int(queue.qsize()*100/len(p))
                    pr.value=c1
                    prglabel.value = &#x27;Extracting SIC from newly created rasters...&#x27;
                    pStatus.value = f&#x27;{pr.value}%&#x27;
            del imglist0
            ##
            a = np.array(s.get())
            del pool, m, queue
            b = np.transpose(a)
            df[param_to_extract] = b[0]
            df[&#x27;CIS_dates&#x27;] = b[1]
            del s
            if q == &#x27;N&#x27;:
                shutil.rmtree(os.path.join(os.path.dirname(self.inputfile), &#x27;CISraster&#x27;))
                shutil.rmtree(os.path.join(os.path.dirname(self.inputfile), &#x27;CIS_shp&#x27;))
        df.to_csv(outfile,
                  sep=&#x27;,&#x27;, index=False, header=1)
        output_shp = os.path.split(self.inputfile)[1][:-4] + &#x27;_{0}_{1}_SHP&#x27;.format(param_to_extract, rstsource) # Name of the output shapefile
        self.createShapefile(df, output_shp, time_header, prglabel)
        prglabel.value = &#x27;Processing Finished!!&#x27;
        pStatus.value = f&#x27;{pr.value}%&#x27;
        output_gpkg = os.path.split(self.inputfile)[1][:-4] + &#x27;_{0}_{1}_gpkg&#x27;.format(param_to_extract, rstsource) # Name of the output Geopackage (gpkg) file
        if not os.path.exists(os.path.join(os.path.dirname(self.inputfile), output_gpkg)):
            os.makedirs(os.path.join(os.path.dirname(self.inputfile), output_gpkg))
        gpkgfile = os.path.join(os.path.dirname(self.inputfile), output_gpkg, output_gpkg + &#x27;.gpkg&#x27;)
        os.system(f&#x27;ogr2ogr -a_srs EPSG:4326 -oo X_POSSIBLE_NAMES=Lon* -oo Y_POSSIBLE_NAMES=Lat*  -f &quot;GPKG&quot; {gpkgfile} {outfile}&#x27;) # Creates the gpkg file from the shapefile. This can be created directly from the csv.
        return output_shp

    def getSeaIceSource(self, workDir, r, gLocalCopy, prglabel, pr, pStatus):
        &#x27;&#x27;&#x27; The choice between the Sea Ice Data from the Canadian Sea Ice Service and Bremen University is handled
         in this function. When the choice is done, another function is called to take care of the process of
         extracting Sea Ice Concentration from the chosen data source. &#x27;&#x27;&#x27;
        if not os.path.exists(self.inputfile):
            print(&quot;Input file not exists !&quot;)
            exit(-1)
        if r == 1:
            r = &#x27;BU&#x27;
        elif r == 2:
            r = &#x27;CIS&#x27;
        else:
            exit(-1)
        if gLocalCopy == &#x27;y&#x27;:
            gLocalCopy = &#x27;Y&#x27;
        elif gLocalCopy == &#x27;n&#x27;:
            gLocalCopy = &#x27;N&#x27;
        t = datetime.now()
        output_shp = self.ExtractionPixelValues(&#x27;sea_ice_co&#x27;, gLocalCopy, r, prglabel, pr, pStatus)
        print(datetime.now() - t)
        return output_shp

class ccadi_uc3_mapping():
    def __init__(self):
        ## initiate the grid to display the contents of the page ###
        self.gridwindow={}
        self.vbox_widgets = []
        self.gridwindow[&#x27;grid&#x27;] = widgets.GridspecLayout(1,1)
                
        #####

         # read text
        f=open(os.environ[&quot;DATA_PATH&quot;] + &quot;/md_texts/SeaIceConcentration.md&quot;,&quot;r&quot;)
        fc=f.read()
        f.close()
        text_html1 = markdown.markdown(fc)
        del fc
        self.gridwindow[&#x27;InfoSIC&#x27;] = widgets.HTML(text_html1)
        self.vbox_widgets.append(self.gridwindow[&#x27;InfoSIC&#x27;])
        # Fields
        self.wdField = widgets.Text(
            value=os.path.join(&quot;2016_int_btl_csv&quot;, &quot;merged_btl_nutrient_pyco2sys.csv&quot;),
            layout=widgets.Layout(width=&#x27;max-content&#x27;)
        )

        self.chkb1 = widgets.Checkbox(
            value=False,
            description=&#x27;Canadian Ice Service&#x27;,
            disabled=False,
            indent=False
        )
        self.chkb2 = widgets.Checkbox(
            value=False,
            description=&#x27;Bremen University&#x27;,
            disabled=False,
            indent=False
        )
        self.chkb3 = widgets.Checkbox(
            value=False,
            description=&#x27;Keep a local copy of the raster images&#x27;,
            disabled=False,
            indent=False
        )
        self.gridwindow[&#x27;checkbox&#x27;] = widgets.VBox(children=[self.chkb1, self.chkb2, self.chkb3])
        self.vbox_widgets.append(self.gridwindow[&#x27;checkbox&#x27;])
        self.prg = widgets.IntProgress(
            value=0,
            min=0,
            max=100,
            bar_style=&#x27;success&#x27;,
            style={&#x27;bar_color&#x27;: &#x27;green&#x27;},
            orientation=&#x27;horizontal&#x27;,
            layout=widgets.Layout(width=&#x27;800px&#x27;)
        )
        self.status = widgets.Label(value=f&#x27;{self.prg.value}%&#x27;, layout=widgets.Layout(width=&#x27;max-content&#x27;))
        self.prg_label = widgets.Label(&#x27;&#x27;, layout=widgets.Layout(width=&#x27;max-content&#x27;))
        self.vbox_widgets.append(self.prg_label)
        self.gridwindow[&#x27;progressbar&#x27;] = widgets.HBox(children=[self.prg, self.status])
        self.vbox_widgets.append(self.gridwindow[&#x27;progressbar&#x27;])
        self.okButton = widgets.Button(description=&quot;OK&quot;)
        
        self.okButton.on_click(self.clickOkbutton)
        #####
        
        self.UC3_mapping()


    def check_checkBox(self):
        c = 0
        value = &#x27;&#x27;
        q = &#x27;n&#x27;
        if self.chkb1.value==True:
            value = self.chkb1.description
            c = 2
        if self.chkb2.value==True:
            value = self.chkb2.description
            c = 1
        if (self.chkb3.value==True):
            q = &#x27;y&#x27;
        return c, q


    def clickOkbutton(self, b):
        self.prg.value=0
        self.prg_label.value = &#x27;Processing...&#x27;
        workDir = os.path.dirname(self.wdField.value)
        if not os.path.exists(workDir):
            os.makedirs(workDir)
        inputfile = self.wdField.value
        r, q = self.check_checkBox()
        output_shp = addSeaIceConcentration(inputfile).getSeaIceSource(workDir, r, q, self.prg_label, self.prg, self.status)
        

    def UC3_mapping(self): 
        def on_button_clicked(b):
            showmap()

        out=widgets.Output()
        @out.capture()
        def showmap():

            workDir=os.path.join(&quot;2016_int_btl_csv&quot;)
            shp=os.path.join(workDir, &quot;merged_btl_nutrient_pyco2sys_sea_ice_co_CIS_SHP&quot;, &quot;merged_btl_nutrient_pyco2sys_sea_ice_co_CIS_SHP.shp&quot;)
            data_full=gpd.read_file(shp)
                        
            # Create a Geo-id which is needed by the Folium (it needs to have a unique identifier for each row)
            data_full[&#x27;geoid&#x27;] = data_full.index.astype(str)

#             dataf_0m=data.loc[np.round(data[&quot;sample_dep&quot;].values)==1]
            dataf_10m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==10]
            dataf_20m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==20]
            dataf_30m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==30]
            dataf_40m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==40]
            dataf_50m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==50]
            dataf_60m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==60]
            dataf_70m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==70]
            dataf_80m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==80]
            dataf_90m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==90]
            dataf_100m=data_full.loc[np.round(data_full[&quot;sample_dep&quot;].values)==100]

            ###

            lonCent = (data_full.bounds.maxx + data_full.bounds.minx).mean()/2
            latCent = (data_full.bounds.maxy + data_full.bounds.miny).mean()/2
            # creating a map object
            m = leafmap.folium.Map(location=(latCent,lonCent), projections=&quot;epsg3575&quot;, zoom_start=6)
            #rst = os.path.join(&quot;2016_int_btl_csv&quot;,&quot;CISraster&quot;,&quot;cis_SGRDREA_20160606T1800Z_pl_a.tif&quot;)

            ###
            # Create the variable plot upon click on the stations on the map
            def chart_func(df, st): #new function
                chart_temp = alt.Chart(df).mark_line(color=&#x27;red&#x27;).transform_fold(
                    fold=[&#x27;CTDTmp90&#x27;, &#x27;sample_dep&#x27;], 
                    as_=[&#x27;variable&#x27;, &#x27;value&#x27;]).encode(
                        x=alt.X(&#x27;CTDTmp90:Q&#x27;, 
                                axis=alt.Axis(title=&#x27;Temperature (Â°C)&#x27;, 
                                              titleColor=&#x27;red&#x27;), 
                                scale=alt.Scale(domain=[df[&#x27;CTDTmp90&#x27;].min(), 
                                                        df[&#x27;CTDTmp90&#x27;].max()])),
                        y=alt.Y(&#x27;sample_dep:Q&#x27;,
                                axis=alt.Axis(title=&#x27;Depth (m)&#x27;), 
                                scale=alt.Scale(reverse=True, 
                                                domain=[0, df[&#x27;sample_dep&#x27;].max()])),
                        color=alt.value(&#x27;red&#x27;)
                )
                chart_sal=alt.Chart(df).mark_line(color=&#x27;green&#x27;).transform_fold(
                    fold=[&#x27;P_sal_CTD&#x27;, &#x27;sample_dep&#x27;], 
                    as_=[&#x27;variable&#x27;, &#x27;value&#x27;]).encode(
                        x=alt.X(&#x27;P_sal_CTD:Q&#x27;, 
                                axis=alt.Axis(title=&#x27;Salinity&#x27;, 
                                              titleColor=&#x27;green&#x27;), 
                                scale=alt.Scale(domain=[df[&#x27;P_sal_CTD&#x27;].min(), 
                                                        df[&#x27;P_sal_CTD&#x27;].max()])),
                        y=alt.Y(&#x27;sample_dep:Q&#x27;, 
                                axis=alt.Axis(title=&#x27;Depth (m)&#x27;), 
                                scale=alt.Scale(reverse=True, 
                                                domain=[0, df[&#x27;sample_dep&#x27;].max()])),
                        color=alt.value(&#x27;green&#x27;)
                )
                ufchart=alt.layer(chart_temp, chart_sal, 
                                  title=f&quot;Vertical profil of Salinity and Temperature at Station: {st}&quot;, 
                                  width=400, height=400).resolve_scale(x=&#x27;independent&#x27;).configure_axisTop(titleColor=&#x27;green&#x27;).configure_axisBottom(titleColor=&#x27;red&#x27;).resolve_legend(color=&#x27;independent&#x27;)            
                return ufchart.to_json()
            
            # extract unique coordinates
            data_full=data_full.round({&#x27;latitude&#x27;:3, &#x27;longitude&#x27;:3})
            df=data_full[[&#x27;latitude&#x27;, &#x27;longitude&#x27;]].drop_duplicates() # drop all duplicated coordinates and keep the row indexes
            u=[]
            for i in df.index:  # use the indexes (kept in the precedent lines) to build a new dataframe from df
                u.append(data_full.values[i])
            dg=pd.DataFrame(u, columns=data_full.columns)
            data_coord=dg[[&#x27;station&#x27;, &#x27;latitude&#x27;, &#x27;longitude&#x27;]]
            del dg
            full_profile = leafmap.folium.FeatureGroup(name=&quot;Full profiles&quot;)
            for i, st in zip(df.index, data_coord[&#x27;station&#x27;].values[:]):
                ds0=data_full[
                    [
                        &#x27;sample_dep&#x27;,
                        &#x27;P_sal_CTD&#x27;, 
                        &#x27;station&#x27;, 
                        &#x27;CTDTmp90&#x27;, 
                        &#x27;latitude&#x27;, 
                        &#x27;longitude&#x27;]
                ].loc[
                    data_full[&quot;station&quot;].values==st
                ]
                ds2=ds0.dropna().round({
                    &quot;CTDTmp90&quot;:2, 
                    &quot;P_sal_CTD&quot;:2, 
                    &#x27;latitude&#x27;: 3, 
                    &#x27;longitude&#x27;:3})
                chart=chart_func(ds0, st)
                pp=leafmap.folium.Popup(max_width=600).add_child(leafmap.folium.VegaLite(chart, width=600))
                full_profile.add_child(leafmap.folium.CircleMarker(
                    location=[data_full[&#x27;latitude&#x27;].values[i], data_full[&#x27;longitude&#x27;].values[i]], radius=6,
                    popup=pp,
                ))
            full_profile.add_to(m)
            
            # Select only needed columns           
            data_10m = dataf_10m[[&#x27;geoid&#x27;, &#x27;P_sal_CTD&#x27;, &#x27;station&#x27;, &#x27;sample_dep&#x27;, &#x27;CTDTmp90&#x27;, &#x27;geometry&#x27;]]
            
            # Add data near the sea surface: 10m
            leafmap.folium.features.GeoJson(dataf_10m,
                                            name=&#x27;Data at 10m depth&#x27;,
                                            style_function=lambda x: {&#x27;color&#x27;:&#x27;transparent&#x27;,&#x27;fillColor&#x27;:&#x27;transparent&#x27;,&#x27;weight&#x27;:0},
                                            tooltip=leafmap.folium.features.GeoJsonTooltip(
                                                fields=[
                                                    &#x27;P_sal_CTD&#x27;, 
                                                    &#x27;station&#x27;, 
                                                    &#x27;sample_dep&#x27;, 
                                                    &#x27;CTDTmp90&#x27;],
                                                aliases = [
                                                    &#x27;Practical salinity from CTD&#x27;, 
                                                    &#x27;Station name&#x27;, 
                                                    &#x27;sample depth (m)&#x27;,
                                                    &#x27;Temperature from CTD (Â°C)&#x27;
                                                ],
                                                sticky=False)
                                           ).add_to(m)


            # Select only needed columns
            data_20m = dataf_20m[[&#x27;geoid&#x27;, &#x27;P_sal_CTD&#x27;, &#x27;station&#x27;, &#x27;sample_dep&#x27;, &#x27;CTDTmp90&#x27;, &#x27;geometry&#x27;]]
            
            # Add data near the sea surface: 20m
            leafmap.folium.features.GeoJson(dataf_20m,
                                            name=&#x27;Data at 20m depth&#x27;,
                                            style_function=lambda x: {&#x27;color&#x27;:&#x27;transparent&#x27;,&#x27;fillColor&#x27;:&#x27;transparent&#x27;,&#x27;weight&#x27;:0},
                                            tooltip=leafmap.folium.features.GeoJsonTooltip(
                                                fields=[
                                                    &#x27;P_sal_CTD&#x27;, 
                                                    &#x27;station&#x27;, 
                                                    &#x27;sample_dep&#x27;, 
                                                    &#x27;CTDTmp90&#x27;],
                                                aliases = [
                                                    &#x27;Practical salinity from CTD&#x27;, 
                                                    &#x27;Station name&#x27;, 
                                                    &#x27;sample depth (m)&#x27;,
                                                    &#x27;Temperature from CTD (Â°C)&#x27;
                                                ],
                                                sticky=False)
                                           ).add_to(m)
            
            # Select only needed columns
            data_30m = dataf_30m[[&#x27;geoid&#x27;, &#x27;P_sal_CTD&#x27;, &#x27;station&#x27;, &#x27;sample_dep&#x27;, &#x27;CTDTmp90&#x27;, &#x27;geometry&#x27;]]
            
            # Add data near the sea surface: 30m
            leafmap.folium.features.GeoJson(dataf_30m,
                                            name=&#x27;Data at 30m depth&#x27;,
                                            style_function=lambda x: {
                                                &#x27;color&#x27;:&#x27;transparent&#x27;,
                                                &#x27;fillColor&#x27;:&#x27;transparent&#x27;,
                                                &#x27;weight&#x27;:0
                                            },
                                            tooltip=leafmap.folium.features.GeoJsonTooltip(
                                                fields=[
                                                    &#x27;P_sal_CTD&#x27;, 
                                                    &#x27;station&#x27;, 
                                                    &#x27;sample_dep&#x27;, 
                                                    &#x27;CTDTmp90&#x27;],
                                                aliases = [
                                                    &#x27;Practical salinity from CTD&#x27;, 
                                                    &#x27;Station name&#x27;, 
                                                    &#x27;sample depth (m)&#x27;,
                                                    &#x27;Temperature from CTD (Â°C)&#x27;
                                                ],
                                                sticky=False)
                                           ).add_to(m)

            # Select only needed columns
            data_40m = dataf_40m[[&#x27;geoid&#x27;, &#x27;P_sal_CTD&#x27;, &#x27;station&#x27;, &#x27;sample_dep&#x27;, &#x27;CTDTmp90&#x27;, &#x27;geometry&#x27;]]
            
            # Add data near the sea surface: 40m
            leafmap.folium.features.GeoJson(dataf_40m,
                                            name=&#x27;Data at 40m depth&#x27;,
                                            style_function=lambda x: {
                                                &#x27;color&#x27;:&#x27;transparent&#x27;,
                                                &#x27;fillColor&#x27;:&#x27;transparent&#x27;,
                                                &#x27;weight&#x27;:0
                                            },
                                            tooltip=leafmap.folium.features.GeoJsonTooltip(
                                                fields=[
                                                    &#x27;P_sal_CTD&#x27;, 
                                                    &#x27;station&#x27;, 
                                                    &#x27;sample_dep&#x27;, 
                                                    &#x27;CTDTmp90&#x27;],
                                                aliases = [
                                                    &#x27;Practical salinity from CTD&#x27;, 
                                                    &#x27;Station name&#x27;, 
                                                    &#x27;sample depth (m)&#x27;,
                                                    &#x27;Temperature from CTD (Â°C)&#x27;
                                                ],
                                                sticky=False)
                                           ).add_to(m)
#           # Select only needed columns
            data_50m = dataf_50m[[&#x27;geoid&#x27;, &#x27;P_sal_CTD&#x27;, &#x27;station&#x27;, 
                                  &#x27;sample_dep&#x27;, &#x27;CTDTmp90&#x27;, &#x27;geometry&#x27;, 
                                  &#x27;latitude&#x27;, &#x27;longitude&#x27;]]
    
            # Add data near the sea surface: 50m
            leafmap.folium.features.GeoJson(dataf_50m,
                                            name=&#x27;Data at 50m depth&#x27;,
                                            style_function=lambda x: {
                                                &#x27;color&#x27;:&#x27;transparent&#x27;,
                                                &#x27;fillColor&#x27;:&#x27;transparent&#x27;,
                                                &#x27;weight&#x27;:0
                                            },
                                            tooltip=leafmap.folium.features.GeoJsonTooltip(
                                                fields=[
                                                    &#x27;P_sal_CTD&#x27;, 
                                                    &#x27;station&#x27;, 
                                                    &#x27;sample_dep&#x27;, 
                                                    &#x27;CTDTmp90&#x27;],
                                                aliases = [
                                                    &#x27;Practical salinity from CTD&#x27;, 
                                                    &#x27;Station name&#x27;, 
                                                    &#x27;sample depth (m)&#x27;,
                                                    &#x27;Temperature from CTD (Â°C)&#x27;
                                                ],
                                                sticky=False)
                                           ).add_to(m)

#             ######################################################################################################################

            leafmap.folium.LayerControl().add_to(m)
            display(m)
        
        self.showmap_button=widgets.Button(
                description=&#x27;Show Map&#x27;,
                disabled=False,
                button_style=&#x27;&#x27;, 
                tooltip=&#x27;Click me&#x27;,
                icon=&#x27;&#x27;
                )
        self.gridwindow[&#x27;ok_and_continue&#x27;] = widgets.HBox(children=[self.okButton, self.showmap_button])
        self.vbox_widgets.append(self.gridwindow[&#x27;ok_and_continue&#x27;])
        
        self.gridwindow[&#x27;grid&#x27;][0, 0] = widgets.VBox(children=self.vbox_widgets)  #
        
        self.accordion0 = widgets.Accordion(
            children=[widgets.HBox(children = [self.gridwindow[&#x27;grid&#x27;][0, 0]])]
        )
        self.accordion0.set_title(0, &#x27;Adding Sea Ice Concentrations into the combined BTL_Nutrient file.&#x27;)
        display(self.accordion0)

        self.showmap_button.on_click(on_button_clicked)
        display(out)
    


    </code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="FVfgoqebrLG7yUOSSik7z" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left"></div></div><div id="xSANu18Tfg" class="myst-jp-nb-block relative group/block"><div class="myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden"><div class="flex absolute top-0 right-0"></div></div><div class="myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex"><div class="absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800"></div></div><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">merging_gui_jupiter()</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><div data-name="outputs-container" data-mdast-node-id="FY7jiOdGeGtBoJQzLrBsu" class="max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative text-left mb-5"><div><div class="p-2.5">Loading...</div></div><div><div class="p-2.5">Loading...</div></div><div><div class="p-2.5">Loading...</div></div><div data-name="safe-output-text" class="font-mono text-sm whitespace-pre-wrap myst-jp-safe-output-text"><code><span>&lt;__main__.merging_gui_jupiter at 0x7f0b9779c6d0&gt;</span></code></div></div></div><div class="myst-backmatter-parts"></div></article></main><script>((a,l)=>{if(!window.history.state||!window.history.state.key){let u=Math.random().toString(32).slice(2);window.history.replaceState({key:u},"")}try{let d=JSON.parse(sessionStorage.getItem(a)||"{}")[l||window.history.state.key];typeof d=="number"&&window.scrollTo(0,d)}catch(u){console.error(u),sessionStorage.removeItem(a)}})("positions", null)</script><link rel="modulepreload" href="/polartep_notebooks/build/entry.client-PCJPW7TK.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-AQ2CODAG.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-JJXTQVMA.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-OZE3FFNP.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-OYMW4E3D.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-C4DFGG5C.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-J7TUH54J.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-FZ2S7OYD.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-JEM6JXYA.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-34XIY2DH.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-KQM5FBHR.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-OCWQY3HK.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-7HNKBP4B.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-CUKUDK3R.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-3EBOCCHJ.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-O4VQNZ62.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-4OEDG4JQ.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-GUCIBHGO.js"/><link rel="modulepreload" href="/polartep_notebooks/build/root-CXYA7X5D.js"/><link rel="modulepreload" href="/polartep_notebooks/build/_shared/chunk-DATP5P2X.js"/><link rel="modulepreload" href="/polartep_notebooks/build/routes/$-JRBPULBO.js"/><script>window.__remixContext = {"url":"/notebooks/ccadi-uc3","state":{"loaderData":{"root":{"config":{"version":3,"myst":"1.7.0","options":{"hide_toc":true,"hide_footer_links":true,"folders":true},"nav":[],"actions":[],"projects":[{"subject":"Notebook examples","title":"PolarTEP Notebooks","description":"Collection of examples relevant to the PolarTEP","github":"https://github.com/gtif-cerulean/polartep_notebooks","id":"5aa0318b-5bc1-41e2-b1d4-053e8b61961b","exports":[],"bibliography":[],"index":"readme","pages":[{"title":"Notebooks","level":1},{"slug":"notebooks.d-viewer-specklia-example","title":"Important! You must generate a Specklia access key before running this workbook","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.ccadi-uc3","title":"Ccadi U C3","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.sice","title":"SICE","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.xcube-tutorial","title":"PolarTEP eScience Lab:  Using XCube in Polar-TEP to Generate NDVI","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2}]}]},"CONTENT_CDN_PORT":"3100","MODE":"static","BASE_URL":"/polartep_notebooks"},"routes/$":{"config":{"version":3,"myst":"1.7.0","options":{"hide_toc":true,"hide_footer_links":true,"folders":true},"nav":[],"actions":[],"projects":[{"subject":"Notebook examples","title":"PolarTEP Notebooks","description":"Collection of examples relevant to the PolarTEP","github":"https://github.com/gtif-cerulean/polartep_notebooks","id":"5aa0318b-5bc1-41e2-b1d4-053e8b61961b","exports":[],"bibliography":[],"index":"readme","pages":[{"title":"Notebooks","level":1},{"slug":"notebooks.d-viewer-specklia-example","title":"Important! You must generate a Specklia access key before running this workbook","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.ccadi-uc3","title":"Ccadi U C3","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.sice","title":"SICE","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.xcube-tutorial","title":"PolarTEP eScience Lab:  Using XCube in Polar-TEP to Generate NDVI","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2}]}]},"page":{"version":3,"kind":"Notebook","sha256":"5190bc9db074a009b5dd1888b2610f3b3478ccb2eec4b60b8f1923e86eb74bcd","slug":"notebooks.ccadi-uc3","location":"/notebooks/ccadi_UC3.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"conda-env-users-edc-2023.03-02-py","display_name":"users-edc-2023.03-02","language":"python"},"github":"https://github.com/gtif-cerulean/polartep_notebooks","subject":"Notebook examples","numbering":{"title":{"offset":1}},"source_url":"https://github.com/gtif-cerulean/polartep_notebooks/blob/main/notebooks/ccadi_UC3.ipynb","edit_url":"https://github.com/gtif-cerulean/polartep_notebooks/edit/main/notebooks/ccadi_UC3.ipynb","exports":[{"format":"ipynb","filename":"ccadi_UC3.ipynb","url":"/polartep_notebooks/build/ccadi_UC3-3809f089b79b7156e64f58d4dfdc89b4.ipynb"}]},"widgets":{"application/vnd.jupyter.widget-state+json":{"state":{},"version_major":2,"version_minor":0}},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"!pip3 install altair===4.2.2\n!pip3 install PyCO2SYS==1.8.2\n!pip3 install leafmap==0.17.1\n!pip3 install erddapy===1.2.1\n!pip3 install ipywidgets==8.0.4","visibility":"show","key":"r3FnZPqVIo"},{"type":"outputs","id":"5N4AKXR-IVgpwoKSCz4lL","children":[],"visibility":"show","key":"aLaW4yDkHq"}],"visibility":"show","key":"VKzx1IWnOI"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import urllib.request as request\nimport h5py\nimport os\nfrom ipywidgets import widgets, IntSlider, jslink, interact, interactive, fixed, interact_manual\nimport markdown\nfrom erddapy import ERDDAP\nfrom ipyleaflet import Map, Marker, GeoData, ImageOverlay, basemaps, basemap_to_tiles, LayersControl, ScaleControl, FullScreenControl, WidgetControl\n# import pandas as pd\nimport numpy as np\n# from IPython.display import display\nfrom netCDF4 import num2date\n# from datetime import datetime\nimport geopandas as gpd\n########################################################\nimport sys\nimport pandas as pd\nimport ipywidgets as widgets\nfrom IPython.display import Markdown, HTML, Javascript, display, Image\nimport subprocess\nimport csv\nfrom __future__ import print_function\n# from ipywidgets import interact, interactive, fixed, interact_manual\nimport csv\nimport re\nimport warnings\n#from init import *\nwarnings.simplefilter(action='ignore', category=pd.errors.PerformanceWarning)\ndef printmd(string):\n    display(Markdown(string))\n###############################################################\nfrom ftplib import FTP\nimport multiprocessing as mlp\nimport shutil\nimport tempfile\nimport urllib.request\nfrom datetime import datetime, timedelta\n\nfrom osgeo import gdal\n# import numpy as np\nfrom osgeo import ogr\nfrom osgeo import osr\n# import pandas as pd\nimport pyproj\n\nfrom multiprocessing import Manager\n# from ipywidgets import widgets, IntSlider, jslink\nfrom ipyleaflet import Map, projections, GeoData, basemap_to_tiles, basemaps, WidgetControl, ScaleControl, FullScreenControl, LayersControl #, ImageOverlay, \nimport geopandas as gpd\nimport leafmap\nimport altair as alt\n# import localtileserver  # was needed localy to be able to add raster on the leafmap Map.","key":"uPxSXZXDxM"},{"type":"outputs","id":"gDhQMcYHlkpABKGaz0O1K","children":[],"key":"xZHOyHgo1H"}],"key":"Nf1VUJsej4"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"class merge_btl_nutrient:\n    \n    def get_btlfile(self, btl_url, wdir):\n        request.urlretrieve(btl_url, os.path.join(wdir, \"btl.h5\"))\n        return 0\n\n    def btl_to_dataframe(self, wdir):\n        f = h5py.File(os.path.join(wdir, \"btl.h5\"), 'r')\n        df_btl = pd.DataFrame()\n        for grp in f:\n            tempo_list = []\n            tempo_columns = []\n            for c in f[grp]:\n                tempo_columns.append(c)\n                tempo_list.append(f[grp][c])\n            list_array = np.transpose(np.array(tempo_list))\n            tempo_df = pd.DataFrame(list_array, columns=tempo_columns)\n            tempo_df['station'] = [f[grp].attrs['Station'].strip().split(' ')[-1]] * len(tempo_df)\n            tempo_df['cast'] = [int(f[grp].attrs['Cast_Number'].strip())] * len(tempo_df)\n            df_btl = pd.DataFrame.append(tempo_df, df_btl)\n        f.close()\n#         # added to extract a csv format of the btl.h5 data to send out to the GUI team\n#         df_btl.to_csv(os.path.join(wdir, \"btl.csv\"), header=1, index=0)\n        #######\n        return df_btl\n\n    def merge(self, df_nutrient, df_btl, file_ge_btl):\n        ge_time_header = [i for i in list(df_nutrient.columns) if\n                          ((i.lower().__contains__('date')) or \n                           (i.lower().__contains__('time')))].pop()\n        btl_time_header = [i for i in list(df_btl.columns) if\n                           ((i.lower().__contains__('date')) or \n                           (i.lower().__contains__('time')))].pop()\n        ge_station_header = [i for i in list(df_nutrient.columns) if\n                             i.lower().__contains__('station')].pop()\n        btl_station_header = [i for i in list(df_btl.columns) if\n                              i.lower().__contains__('station')].pop()\n        ge_bottle_header = [i for i in list(df_nutrient.columns) if\n                            (i.lower().__contains__('bottle'))].pop()\n        \"\"\" TODO: bopo should be replacet with RosPos when the data with the corrected variable name will be served on Hyrax.\"\"\"\n        btl_bottle_header = [i for i in list(df_btl.columns) if\n                             i.lower().__contains__('bopo')].pop() \n        ge_cast_header = [i for i in list(df_nutrient.columns) if\n                          i.lower().__contains__('cast')].pop()\n        btl_cast_header = [i for i in list(df_btl.columns) if\n                           i.lower().__contains__('cast')].pop()\n        ge_jointField = [ge_time_header, ge_station_header, ge_bottle_header, ge_cast_header]\n        btl_jointField = [btl_time_header, btl_station_header, btl_bottle_header, btl_cast_header]\n        \n        #####################################\n        df_nutrient_header = [h.split(' ')[0] for h in df_nutrient.columns]\n        df_nutrient.columns = df_nutrient_header\n        dfnutrient_to_merge = df_nutrient\n        dfbtl_to_merge = df_btl\n        dfbtl_to_merge = dfbtl_to_merge.drop(btl_time_header, axis=1)\n        dfnutrient_to_merge = dfnutrient_to_merge.drop(ge_time_header, axis=1)\n        dfnutrient_to_merge = dfnutrient_to_merge.drop(ge_station_header, axis=1)\n        dfnutrient_to_merge[ge_time_header] = pd.to_datetime(df_nutrient[ge_time_header]).dt.strftime('%Y-%m-%d')\n        # dfnutrient_to_merge[ge_time_header] = df_nutrient[ge_time_header].dt.strftime('%Y-%m-%d')\n        u = []\n        for i in df_nutrient[ge_station_header].values:\n            if i.isdigit():\n                u.append('G' + i)\n            else:\n                u.append(i)\n        dfnutrient_to_merge[ge_station_header] = u\n        hdf_time_units = \"days since 1970-01-01 00:00:00\"\n        list_tmp = []\n        import cftime\n        for i in range(len(df_btl[btl_time_header])):\n            u=num2date(df_btl[btl_time_header].values[i], hdf_time_units)\n            u=cftime.DatetimeGregorian.strftime(u, '%Y-%m-%d')\n            list_tmp.append(u)\n        dfbtl_to_merge[btl_time_header] = list_tmp\n        '''https://www.datasciencemadesimple.com/join-merge-data-frames-pandas-python/'''\n        df = pd.merge(dfnutrient_to_merge, dfbtl_to_merge, how=\"inner\", left_on=ge_jointField, right_on=btl_jointField)\n        df.to_csv(file_ge_btl, header=1, index=0)\n        del df\n        return 0\n\n\nclass merging_gui_jupiter():\n    # This is the class where the GUI is made\n    def __init__(self):\n        self.gridwindow={} # making an empty grid window\n        self.vbox_widgets = [] # making an empty vertical box\n        self.gridwindow['grid'] = widgets.GridspecLayout(1, 1)\n        #####\n        self.getBTLbutton = widgets.Button(description=\"retrieve\", layout=widgets.Layout(width='max-content'), button_style='info')\n        self.getNutrientbutton = widgets.Button(description=\"retrieve\", layout=widgets.Layout(width='max-content'), button_style='info')\n        self.Continuebutton = widgets.Button(description=\"Continue\", layout=widgets.Layout(width='max-content'))\n        # BTL file retrieval\n        layout = widgets.Layout(height='auto', width='125px')\n        printmd('\u003ch1\u003e\u003cb\u003eMerging bottle file with the nutrient file\u003c/b\u003e\u003c/h1\u003e')\n        # read text\n        f=open(os.environ[\"DATA_PATH\"] + \"/md_texts/nutrient_btl_infos.md\",\"r\")\n        fc=f.read()\n        f.close()\n        text_html1 = markdown.markdown(fc)\n        del fc\n        self.gridwindow['text1'] = widgets.HTML(text_html1)\n#         # Reading the images of the CTD-Rosette ##########\n        ctd_img = open(os.environ[\"DATA_PATH\"] + \"/images/ctd-rosette.jpg\", \"rb\")\n        ship_img = open(os.environ[\"DATA_PATH\"] + \"/images/CCGSAmundsen.png\", 'rb')\n        ctd = ctd_img.read()\n        ship = ship_img.read()\n        gridimage1 = widgets.Image(value=ship, format='jpg', width=300)\n        Figure1 = widgets.Label(r'\\(\\textbf{Figure 1:}\\)'+' Canadian Coast Guard Ship ' + r'\\(\\textit{Amundsen}\\)', layout=widgets.Layout(height='auto', width='auto'))\n        gridimage2 = widgets.Image(value=ctd, format='png', width=300)\n        Figure2 = widgets.Label(r'\\(\\textbf{Figure 2:}\\)'+' CTD-Rosette', layout=widgets.Layout(height='auto', width='auto'))\n        ship_img.close()\n        ctd_img.close()\n        image_vbox1 = widgets.VBox(children=[gridimage1, Figure1])\n        image_vbox2 = widgets.VBox(children=[gridimage2, Figure2])\n        self.gridwindow['image'] = widgets.HBox(children=[image_vbox1, image_vbox2])\n# #         image_vbox = [[gridimage1, gridimage2], ['CCGS Amundsen', 'CTD-Rosette']]\n#         gridwindow['image'] = widgets.HBox(children=[gridimage2, gridimage1])\n        ###################################################\n        self.vbox_widgets.append(self.gridwindow['text1'])\n        self.vbox_widgets.append(self.gridwindow['image'])\n        \n                # read text\n        f=open(os.environ[\"DATA_PATH\"] + \"/md_texts/data_retrieval.md\",\"r\")\n        fc=f.read()\n        f.close()\n        data_retrieval = markdown.markdown(fc)\n        del fc\n        self.gridwindow['data_retrieval'] = widgets.HTML(data_retrieval)\n        self.vbox_widgets.append(self.gridwindow['data_retrieval'])\n        ## Bottle file retrieval ######\n        label = widgets.Label('Bottle files', layout=layout)\n        self.BottleData = widgets.Text(\n            value=\"http://jorvik.uwaterloo.ca:8080/opendap/data/CCADI/Amundsen_BTL_GreenEdge2016_LEG1.h5\",\n            layout=widgets.Layout(width='50%')\n        )\n        self.gridwindow['bottle'] = widgets.HBox(children=[label, self.BottleData, self.getBTLbutton])\n        self.vbox_widgets.append(self.gridwindow['bottle'])\n        label = widgets.Label('Nutrient file', layout=layout)\n        self.nutrientServer = widgets.Text(\n            value=\"https://CanWINerddap.ad.umanitoba.ca/erddap\",\n            layout=widgets.Layout(width='50%')\n        )\n        self.gridwindow['nutrientserver'] = widgets.HBox(children=[label, self.nutrientServer, self.getNutrientbutton])\n        self.vbox_widgets.append(self.gridwindow['nutrientserver'])\n        \n        self.list0 = widgets.SelectMultiple(\n            options=[\"Empty\"],\n            value=[\"Empty\"],\n            disabled=False\n        )\n\n        self.list1 = widgets.SelectMultiple(\n            options=[\"Empty\"],\n            value=[\"Empty\"],\n            disabled=False\n        )\n        \n        self.depthRange = widgets.FloatRangeSlider(\n                value=[0, 0],\n                min=0,\n                max=5000,\n                step=0.1,\n                disabled=False,\n                continuous_update=False,\n                orientation='horizontal',\n                readout=True,\n                readout_format='.1f',\n        )\n        \n        self.outputdir = \"2016_int_btl_csv\"\n        self.gridwindow['grid'][0, 0] = widgets.VBox(children=self.vbox_widgets)  # pass all the content of the vertical box into the left side of the grid\n        \n        self.getBTLbutton.on_click(self.getBTLdata)\n        self.getNutrientbutton.on_click(self.getNutrientdata)\n        display(self.gridwindow['grid'])\n        self.Merge_Button=widgets.Button(\n            description='Merge',\n            disabled=False,\n            button_style='', \n            tooltip='Click me',\n            icon=''\n            )\n        self.merge_btl_nutrient()\n        \n        \n        ###########\n             \n    def continue_to_pyco2sys(self): \n        def on_button_pyco2sys(b):\n            continueprocess()\n\n        outmerge=widgets.Output()\n        @outmerge.capture()\n        def continueprocess():\n            checkInputfile()\n#             self.continue_to_sic()\n        \n        gridwindow={}\n        vbox_widgets = []\n        gridwindow['grid'] = widgets.GridspecLayout(1,1)\n        layout = widgets.Layout(height='auto', width='125px')\n        f=open(os.environ[\"DATA_PATH\"] + \"/md_texts/variable_Join_list.md\",\"r\")\n        fc=f.read()\n        f.close()\n        text_var_sel = markdown.markdown(fc)\n        del fc\n        gridwindow['variable_selection'] = widgets.HTML(text_var_sel)\n        vbox_widgets.append(gridwindow['variable_selection'])\n        label = widgets.Label('Bottle_variables', layout=widgets.Layout(width='50%'))\n        label = widgets.Label('Nutrient variables', layout=widgets.Layout(width='50%'))\n        gridwindow['bottle variable list'] = widgets.HBox(children=[label, self.list0])\n\n        gridwindow['nutrient variable list'] = widgets.HBox(children=[label, self.list1])\n        gridwindow['var_list'] = widgets.HBox(children=[gridwindow['bottle variable list'], gridwindow['nutrient variable list']])\n        vbox_widgets.append(gridwindow['var_list'])\n        label = widgets.Label('Sample depth:', layout=layout)\n        # read text\n        f=open(os.environ[\"DATA_PATH\"] + \"/md_texts/variable_meaning.md\",\"r\")\n        fc=f.read()\n        f.close()\n        text_var = markdown.markdown(fc)\n        del fc\n        gridwindow['variable_meaning'] = widgets.HTML(text_var)\n        # read text\n        f=open(os.environ[\"DATA_PATH\"] + \"/md_texts/sample_depth_range.md\",\"r\")\n        fc=f.read()\n        f.close()\n        text_var_sel = markdown.markdown(fc)\n        del fc\n        gridwindow['sample_depth_range'] = widgets.HTML(text_var_sel)\n        vbox_widgets.append(gridwindow['sample_depth_range'])\n        gridwindow['Sample depth'] = widgets.HBox(children=[label, self.depthRange])\n        vbox_widgets.append(gridwindow['Sample depth'])\n\n        self.btl = pd.DataFrame()\n        self.nutrient=pd.DataFrame()\n        \n        continue_button1=widgets.Button(\n            description='Continue',\n            disabled=False,\n            button_style='', \n            tooltip='Click me',\n            icon=''\n            )\n        gridwindow['merge'] = widgets.HBox(children=[self.Merge_Button])\n        gridwindow['to_pyco2sys'] = widgets.HBox(children=[gridwindow['merge'], continue_button1])\n        vbox_widgets.append(gridwindow['to_pyco2sys'])\n        gridwindow['grid'][0, 0] = widgets.VBox(children=vbox_widgets)\n        self.Merge_Button.on_click(self.clickMerge)\n        continue_button1.on_click(on_button_pyco2sys)\n        display(gridwindow['grid'])\n        display(outmerge)\n        return 0       \n\n\n        \n    def merge_btl_nutrient(self): \n        def on_button_continuemerge(b):\n            continuemerge()\n\n        out=widgets.Output()\n        @out.capture()\n        def continuemerge():           \n            ###### transit to the PyCO2SYS #####\n            self.continue_to_pyco2sys()\n            \n\n        self.continue_button=widgets.Button(\n            description='continue',\n            disabled=False,\n            button_style='', \n            tooltip='Click me',\n            icon=''\n            )\n        self.gridwindow['continue'] = widgets.HBox(children=[self.continue_button])\n        self.vbox_widgets.append(self.gridwindow['continue'])\n        self.gridwindow['grid'][0, 0] = widgets.VBox(children=self.vbox_widgets)\n        self.continue_button.on_click(on_button_continuemerge)\n        display(out)\n\n    def getBTLdata(self,a):\n        if not os.path.exists(self.outputdir):\n            os.makedirs(self.outputdir)\n        merge_btl_nutrient().get_btlfile(self.BottleData.value, self.outputdir)\n        df_btl=merge_btl_nutrient().btl_to_dataframe(self.outputdir)\n        self.list0.options=tuple(df_btl.columns)\n        self.list0.value=[\"BOPO\",\"CTDTmp90\",\"Cast_Number\",\"P_sal_CTD\",\"Pres_Z\",\"depth\",\"latitude\",\"longitude\",\"time\",\"station\"]\n        self.list0.rows = 24\n        self.depthRange.min = df_btl['depth'].min()\n        self.depthRange.max = df_btl['depth'].max()\n        self.depthRange.value = [self.depthRange.min, self.depthRange.max]\n        self.getBTLbutton.description=\"Success!\"\n        self.getBTLbutton.button_style='success'\n        del df_btl\n        return 0\n    \n    def getNutrientdata(self, a):\n        if not os.path.exists(self.outputdir):\n            os.makedirs(self.outputdir)\n        e_DataSearch = ERDDAP(server=self.nutrientServer.value)\n        result_search = e_DataSearch.get_search_url(search_for=\"greenedge\", response=\"csv\")\n        self.datasetID = [k \n                          for k in pd.read_csv(result_search)[\"Dataset ID\"] \n                          if k.lower().__contains__(\"greenedge_nutrient\")].pop()\n        #self.datasetID = pd.read_csv(result_search)[\"Dataset ID\"][0]\n        #print(result_search)\n\n        e_datafetch = ERDDAP(server=self.nutrientServer.value, protocol=\"tabledap\", response=\"csv\")\n        e_datafetch.dataset_id = self.datasetID\n\n        df_nutrient = e_datafetch.to_pandas(parse_dates=True)\n        file_ge = os.path.join(self.outputdir, f'{self.datasetID}.csv')  ## Nutrient file name \n        df_nutrient.to_csv(file_ge, index=False, header=True)\n        self.list1.options=df_nutrient.columns\n        \"\"\" Adjustment done in order to look easily for the variables needed in the data field\"\"\"\n        station = [k for k in df_nutrient.columns if k.lower().__contains__(\"station\")].pop()\n        sample_date = [k for k in df_nutrient.columns if k.lower().__contains__(\"sample_date\")].pop()\n        #sample_date = sample_date.split(\" \")[0]\n        sample_depth = [k for k in df_nutrient.columns if k.lower().__contains__(\"sample_depth\")].pop()\n        #sample_depth = sample_depth.split(\" \")[0]\n        cast = [k for k in df_nutrient.columns if k.lower().__contains__(\"cast\")].pop()\n        bottle = [k for k in df_nutrient.columns if k.lower().__contains__(\"bottle\")].pop()\n        dic_um = [k for k in df_nutrient.columns if k.lower().__contains__(\"dic_um\")].pop()\n        #dic_um = dic_um.split(\" \")[0]\n        totalk = [k for k in df_nutrient.columns if k.lower().__contains__(\"totalk_l_um\")].pop()\n        #totalk = totalk.split(\" \")[0]\n        self.list1.value=[station, sample_date, sample_depth, cast, bottle,dic_um, totalk]\n        self.list1.rows = 24\n        self.getNutrientbutton.description=\"Success!\"\n        self.getNutrientbutton.button_style='success'\n        del df_nutrient\n        return 0\n\n        \n    def clickMerge(self, a):\n        file_ge_btl = os.path.join(self.outputdir, 'merged_btl_nutrient.csv') ## Merged file name to be fed to the PyCO2SYS\n        objectsForMerging = merge_btl_nutrient()\n        if os.path.exists(file_ge_btl):\n            os.remove(file_ge_btl)\n            df_btl = objectsForMerging.btl_to_dataframe(self.outputdir)\n            df_btl.reset_index(drop=True, inplace=True)\n            cond = (df_btl[\"depth\"].values[:]\u003e=self.depthRange.value[0]) \u0026 (df_btl[\"depth\"].values[:]\u003c=self.depthRange.value[1])\n            df_btl = df_btl.loc[cond]\n            df_nutrient = pd.read_csv(os.path.join(self.outputdir, f'{self.datasetID}.csv'), header=0)            \n            objectsForMerging.merge(df_nutrient=df_nutrient[list(self.list1.value)], df_btl=df_btl[list(self.list0.value)], file_ge_btl=file_ge_btl)\n            del df_nutrient, df_btl\n        else:\n            df_btl = objectsForMerging.btl_to_dataframe(self.outputdir)\n            df_btl.reset_index(drop=True, inplace=True)\n            cond = (df_btl[\"depth\"].values[:]\u003e=self.depthRange.value[0]) \u0026 (df_btl[\"depth\"].values[:]\u003c=self.depthRange.value[1])\n            df_btl = df_btl.loc[cond]\n            df_nutrient = pd.read_csv(os.path.join(self.outputdir, f'{self.datasetID}.csv'), header=0)            \n            objectsForMerging.merge(df_nutrient=df_nutrient[list(self.list1.value)], df_btl=df_btl[list(self.list0.value)], file_ge_btl=file_ge_btl)\n            del df_nutrient, df_btl\n        self.Merge_Button.description=\"Done\"\n        self.Merge_Button.button_style=\"success\"\n        return 0\n\n","key":"SQ3gjpojll"},{"type":"outputs","id":"WzuA0FdNWEj7YUmfYwdIF","children":[],"key":"WBk8fB8J6M"}],"key":"vtBs0Cunet"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#Define the required parameters\n\ndef checkInputfile():\n    #Create an empty list for all the required parameters in the file. \n    req_param_inFile=[]\n    opt_param_inFile=[]\n    \n    pd.set_option('display.max_columns', 50)\n    \n    #-------------------INPUT FILE-------------------------------------------\n    input_file =os.path.join(\"2016_int_btl_csv\", \"merged_btl_nutrient.csv\")                \n    df = pd.read_csv(input_file)\n    df=df.reset_index(drop=True)\n    #------------------------------------------------------------------------\n    \n    #Checking for the stadardized names in the input file to automatically pull out all the required, optional and mandatory parameters present\n    \n    # 1. KEY PARAMETERS \n    # Parameters- Total Alkalinity, DIC, PH, PCO2, fCO2, CO232, biCO2\n    \n    standardizedNames=['TotAlk_l_um_l','DIC_um_l','pH','pCO2','fCO2','CO232','biCO2'] #BODC standardized names\n    fullNames=['Total alkalinity (umolkg1)','Dissolved inorganic carbon (umolkg1)','Partial pressure of carbon dioxide (pCO2) (uatm)',\\\n               'Fugacity of carbon dioxide (fCo2) (uatm)','Carbonate ion concentration (CO32) (umolkg1)','Bicarbonate ion (umol kg1)']   # Full name that will show up in widget\n    \n    \n    for name, fname in zip(standardizedNames, fullNames): \n        if name in df.columns:\n            req_param_inFile.append(fname) #Append the names of all the key parameters in the input file\n        \n    \n    # 2. OPTIONAL PARAMETERS \n    # Parameters- SiOx, PO4, Ammonia, Sulfide\n    \n    standardizedNames=['SiOx_um_l','PO4_Filt_um_l','Ammonia','Sulfide'] #BODC standardized names\n    fullNames=['Total Silicate (umolkg1)','Total Phosphate (SRP) (umolkg1)','Total Ammonia (umolkg1)','Total Sulfide (umolkg1)']   # Full name that will show up in widget\n    \n    for name, fname in zip(standardizedNames, fullNames): \n        if name in df.columns:\n            opt_param_inFile.append(fname) #Append the names of all the key parameters in the input file\n    \n    \n    getUserParameters(df, req_param_inFile, opt_param_inFile) \n","key":"JZ9H0MloCO"},{"type":"outputs","id":"dk8zlzIIIciTHFbcCb5ze","children":[],"key":"A1HkDl1m14"}],"key":"ffOc5VCoKD"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def getUserParameters(df,req_param_inFile,opt_param_inFile):\n\n    #The user will be presented with the parameters automatically pulled out from the input file. They will have a chance to make changes to the selections. \n    #Only exception is if there are only two req parameters in input file, they will not be able to make any changes/selctions in this case.\n    \n    #Key Parameters Widget\n    req_param_user=widgets.SelectMultiple(\n        options=req_param_inFile,\n        #value=req_param_inFile,\n        #description='Key Parameters:',\n        disabled=False,\n    )\n    req_param_user.layout.margin='0.5% 0% 5% 0%'\n    req_param_user.layout.width='20%'\n    req_param_user.layout.height='70%'\n\n\n    #Optional Parameters Widget\n    opt_param_user=widgets.SelectMultiple(\n        options=opt_param_inFile,\n        value=opt_param_inFile,\n        #description='Optional Parameters:',\n        disabled=False,\n    )\n    opt_param_user.layout.margin='0.5% 0% 3% 0%'\n    opt_param_user.layout.width='20%'\n\n    cont_button1=widgets.Button(\n    description='Continue',\n    disabled=False,\n    button_style='', \n    tooltip='Click me',\n    icon=''\n    )\n\n    \n    # Onclick function for the first Continue button widget\n    output = widgets.Output()\n    @output.capture()\n    def on_button_clicked(b):\n        getConstants(df, req_param_user, opt_param_user, req_param_inFile, opt_param_inFile)\n    \n\n    # Key parameters, aka carbonate system parameters\n    printmd('### \u003cbr\u003e\u003cbr/\u003e Carbonate System Parameters ###') \n    printmd('More information on these arguments an be found [here](https://pyco2sys.readthedocs.io/en/latest/co2sys_nd/#carbonate-system-parameters).')\n    #if there is only one or no key parameters in input file\n    if len(req_param_inFile)\u003c2:\n        printmd(\"\u003cbr\u003e**There are not enough key parameters for calculation of the full carbonate system. Please check input file and try again.**\u003cbr /\u003e\")\n        sys.exit(-1)\n    \n    #If only two key parameters in the input file, automatically use those two\n    if len(req_param_inFile)==2:\n        printmd(\"\u003cbr\u003e**The following key carbonate parameters were found in the input file and will be used in calculations.**\u003cbr /\u003e\")\n\n        for name in req_param_inFile:\n            printmd('- {}'.format(name))\n \n    #If there are more than two key parameters in the input file, ask user to select any two\n    if len(req_param_inFile)\u003e2:\n        printmd(\"\u003cbr\u003e**The following key carbonate parameters were found in the input file. Choose any two parameters.**\u003cbr /\u003e\")\n        display(req_param_user) #display widget\n\n\n    # Optional parameters, aka Nutrients \u0026 solutes\n    printmd('### \u003cbr\u003e\u003cbr/\u003e Nutrients and other solutes ###') \n    printmd('More information on these arguments an be found [here](https://pyco2sys.readthedocs.io/en/latest/co2sys_nd/#nutrients-and-other-solutes).')\n    \n    # If there is at least one opt parameter in file, display them and ask user to select any of them. All are automatically selected in the widget\n    if len(opt_param_inFile)\u003e0:\n        printmd(\"\u003cbr\u003e**The following nutrient parameters are in the input file. Choose any parameter(s).**\u003c/b\u003e\")\n        display(opt_param_user)   #display widget\n    \n    \n    display(cont_button1) #display continue button\n    cont_button1.on_click(on_button_clicked)  #Call onclick function\n    display(output) #display widget ouput when button is clicked\n    ","key":"T1slSVQyrK"},{"type":"outputs","id":"Wi1_I6-eK8-aq57yqbi-4","children":[],"key":"LnlzKhaUZn"}],"key":"l301QDkpcx"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def getConstants(df, req_param_user, opt_param_user, req_param_inFile, opt_param_inFile):    \n    \n    # Constants\n    printmd('### \u003cbr\u003e\u003cbr/\u003e Settings for constants ###') \n    printmd('More information on these constants an be found [here](https://pyco2sys.readthedocs.io/en/latest/co2sys_nd/#settings). Default constants chosen based on [Jiang et al., 2022](https://www.frontiersin.org/articles/10.3389/fmars.2021.705638/full).')\n    #Widgets for the different constants\n    phstr = widgets.Output()\n    @phstr.capture()\n    def constStrings1():\n        printmd(\"\u003cbr\u003e**Choose the pH scale:**\")\n        \n    constStrings1()\n\n    option_list=['1. Total',\n                 '2. Seawater',\n                 '3. Free',\n                 '4. NBS, i.e. relative to NBS/NIST reference standards']\n    \n    #PH Scale\n    phscale=widgets.RadioButtons(\n        options=option_list,  \n        disabled=False,\n        layout={'width': 'max-content'},\n    )\n    phscale.layout.margin='0.5% 1% 3% 0%'\n    #phscale.layout.width='40%' \n\n\n    # Carbonic Acid Dissociation\n    k1k2str = widgets.Output()\n    @k1k2str.capture()\n    def constStrings2():\n        printmd(\"**Choose the set of equilibrium constant parameterisations to model carbonic acid dissociation:**\")\n    constStrings2()\n\n    option_list=['1. RRV93 (0 \u003c T \u003c 45 Â°C, 5 \u003c S \u003c 45, Total scale, artificial seawater).',\n                '2. GP89 (âˆ’1 \u003c T \u003c 40 Â°C, 10 \u003c S \u003c 50, Seawater scale, artificial seawater).',\n                '3. H73a and H73b refit by DM87 (2 \u003c T \u003c 35 Â°C, 20 \u003c S \u003c 40, Seawater scale, artificial seawater).',\n                '4. MCHP73 refit by DM87 (2 \u003c T \u003c 35 Â°C, 20 \u003c S \u003c 40, Seawater scale, real seawater).',\n                '5. H73a, H73b and MCHP73 refit by DM87(2 \u003c T \u003c 35 Â°C, 20 \u003c S \u003c 40, Seawater scale, real seawater)',\n                '6. MCHP73 aka \"GEOSECS\" (2 \u003c T \u003c 35 Â°C, 19 \u003c S \u003c 43, NBS scale, real seawater).',\n                '7. MCHP73 without certain species aka \"Peng\" (2 \u003c T \u003c 35 Â°C, 19 \u003c S \u003c 43, NBS scale, real seawater).',\n                '8. M79 (0 \u003c T \u003c 50 Â°C, S = 0, freshwater only).',            \n                '9. CW98 (2 \u003c T \u003c 30 Â°C, 0 \u003c S \u003c 40, NBS scale, real estuarine seawater).',\n                '10. LDK00 (2 \u003c T \u003c 35 Â°C, 19 \u003c S \u003c 43, Total scale, real seawater).',\n                '11. MM02 (0 \u003c T \u003c 45 Â°C, 5 \u003c S \u003c 42, Seawater scale, real seawater).',\n                '12. MPL02 (âˆ’1.6 \u003c T \u003c 35 Â°C, 34 \u003c S \u003c 37, Seawater scale, field measurements).',\n                '13. MGH06 (0 \u003c T \u003c 50 Â°C, 1 \u003c S \u003c 50, Seawater scale, real seawater).',\n                '14. M10 (0 \u003c T \u003c 50 Â°C, 1 \u003c S \u003c 50, Seawater scale, real seawater).',\n                '15. WMW14 (0 \u003c T \u003c 45 Â°C, 0 \u003c S \u003c 45, Seawater scale, real seawater).',\n                '16. SLH20 (âˆ’1.67 \u003c T \u003c 31.80 Â°C, 30.73 \u003c S \u003c 37.57, Total scale, field measurements).',\n                '17. SB21 (15 \u003c T \u003c 35 Â°C, 19.6 \u003c S \u003c 41, Total scale, real seawater).']\n    \n    k1k2=widgets.RadioButtons(\n        options=option_list,    \n        value='10. LDK00 (2 \u003c T \u003c 35 Â°C, 19 \u003c S \u003c 43, Total scale, real seawater).',\n        #rows=len(option_list),\n        layout={'width': 'max-content'},\n        disabled=False,\n    )\n    k1k2.layout.margin='0.5% 1% 3% 0%'\n    #k1k2.layout.width='50%'\n    #k1k2.layout.height='100%'\n\n    # Bisulfate ion dissociation \n    kso4str = widgets.Output()\n    @kso4str.capture()\n    def constStrings3():\n        printmd(\"**Choose the equilibrium constant parameterisations to model bisulfate ion dissociation:**\")\n    constStrings3()\n\n    option_list=['1. D90a: Dickson (1990) J. Chem. Thermodyn.',\n                '2. KRCB77: Khoo et al. (1977) Anal. Chem.',\n                '3. WM13: Waters \u0026 Millero (2013) Mar. Chem./ WMW14: Waters et al. (2014) Mar. Chem.']\n    \n    kso4=widgets.RadioButtons(\n        options=option_list,    \n        value='1. D90a: Dickson (1990) J. Chem. Thermodyn.',\n        layout={'width': 'max-content'},\n        #description='Parameter:',\n        disabled=False,\n    )\n    kso4.layout.margin='0.5% 1% 3% 0%'\n    #kso4.layout.width='40%'\n\n    # Total borate \n    bostr = widgets.Output()\n    @bostr.capture()\n    def constStrings4():\n        printmd(\"**Choose which boron:salinity relationship to use to estimate total borate:**\")\n    constStrings4()\n\n    option_list=['1. U74: UppstrÃ¶m (1974) DeepSea Res.',\n                '2. LKB10: Lee et al. (2010) Geochim. Cosmochim. Acta']\n    \n    bo=widgets.RadioButtons(\n        options=option_list,    \n        value='2. LKB10: Lee et al. (2010) Geochim. Cosmochim. Acta',\n        layout={'width': 'max-content'},\n        disabled=False,\n    )\n    bo.layout.margin='0.5% 1% 3% 0%'\n    # bo.layout.width='40%'\n    \n    # hydrogen fluoride dissociation\n    hfstr = widgets.Output()\n    @hfstr.capture()\n    def constStrings5():\n        printmd(\"**Choose which which equilibrium constant parameterisation to use for hydrogen fluoride dissociation:**\")\n    constStrings5()\n\n    option_list=['1. DR79: Dickson \u0026 Riley (1979) Mar. Chem.',\n                '2. PF87: Perez \u0026 Fraga (1987) Mar. Chem.']\n    \n    hf=widgets.RadioButtons(\n        options=option_list,    \n        value='2. PF87: Perez \u0026 Fraga (1987) Mar. Chem.',\n        layout={'width': 'max-content'},\n        disabled=False,\n    )\n    hf.layout.margin='0.5% 1% 3% 0%'\n    # hf.layout.width='40%' \n\n    # opt_gas_constant\n    gcstr = widgets.Output()\n    @gcstr.capture()\n    def constStrings6():\n        printmd(\"**Choose which value to use for the gas constant:**\")\n    constStrings6()\n    option_list=['1. DOEv2',\n                '2. DOEv3',\n                '3. 2018 CODATA']\n    \n    gc=widgets.RadioButtons(\n        options=option_list,    \n        value='3. 2018 CODATA',\n        layout={'width': 'max-content'},\n        disabled=False,\n    )\n    gc.layout.margin='0.5% 1% 3% 0%'\n    # gc.layout.width='40%' \n    \n    #Continue button On-click function\n    output = widgets.Output()\n    @output.capture()\n    def on_button_clicked(b):        \n        runPyco2sys(df,req_param_user, opt_param_user, req_param_inFile, opt_param_inFile, phscale, k1k2, kso4, bo, hf,gc)\n\n    # Button widget\n    button2=widgets.Button(\n    description='Continue',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click me',\n    icon=''\n    )\n\n    box2 = widgets.VBox([phstr,phscale, k1k2str, k1k2, kso4str, kso4, bostr, bo, hfstr, hf, gcstr,gc, button2])\n    display(box2)\n\n    button2.on_click(on_button_clicked)\n    display(output)","key":"bCSEQZMPDC"},{"type":"outputs","id":"Cp8Wd_Sb6i78tqcGzyB3Y","children":[],"key":"sA4metsRcr"}],"key":"veu0XAQ6Ua"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def runPyco2sys(df,req_param_user, opt_param_user, req_param_inFile, opt_param_inFile, phscale, k1k2, kso4, bo, hf,gc):\n\n\n    #Build the argument list for pyco2sys to ingest\n    #The argument names are defined in the PyCO2 sys documentation.\n    kwargs={}\n   \n\n    #KEY PARAMETERS\n    \n    # pyco2sys labels the two key parameters chosen as par 1 and par 2. 'par1check' checks if par1 has yet been assigned, otherwise it sets a key parameter to par 2\n    par1check=\"False\"\n    par2check=\"False\"\n\n    \n    #Check if the parameter was chosen by the user, or if it was automatically selected (only two parameters were in the file). In that case the variable would not be in 'req_param_user' from the widget.\n    #If the varibale is to be used in the calculation, then get the data from the input file (saved as the data frame df)\n    #The variable is then added to the arguments for pyco2sys\n    \n    substrings=['alkalinity','Dissolved inorganic carbon','pH','Partial pressure of carbon dioxide', 'Fugacity of carbon dioxide','Carbonate ion concentration', 'Bicarbonate Ion']\n    standardizedNames=['TotAlk_l_um_l','DIC_um_l','pH','pCO2','fCO2','CO232','biCO2']\n    types=[1,2,3,4,5,6,7]   #These are the different types according to pyco2sys documentation \n    \n    \n    for name, substr, t in zip(standardizedNames, substrings, types):           # Loop through the substrings and the standardized names  \n        if par1check==\"False\" or par2check==\"False\":                            #Check if either par1 or par2 is false. We need at least two key paramaters (par1 and par2 represent these two parameters)\n            if any(substr in string for string in req_param_inFile):            #If it is in the input file\n                if len(req_param_inFile)==2:                                    #If it is one of only two key variables in the input file (here it would not be in 'req_param_user.value' as it would be automatically selected- no widget used)\n   \n                    if par1check==\"True\":        \n                        kwargs['par2']=df[name].to_numpy(dtype=float)            #Get the data using the standardized name from the data frame (input file)\n                        kwargs['par2_type']=t\n                        par2check=\"True\"\n                    else:\n                        kwargs['par1']=df[name].to_numpy(dtype=float)             \n                        kwargs['par1_type']=t\n                        par1check=\"True\"\n\n                elif len(req_param_inFile)\u003e2:                                    # If there are more than two key parameters in the input file\n                    if any(substr in string for string in req_param_user.value): #If there are more than two key variables in the file, then check if the user actually selected this varibale\n                        if par1check==\"True\":        \n                            kwargs['par2']=df[name].to_numpy(dtype=float)          \n                            kwargs['par2_type']=t\n                            par2check=\"True\"\n                        else:\n                            kwargs['par1']=df[name].to_numpy(dtype=float)          \n                            kwargs['par1_type']=t\n                            par1check=\"True\"\n\n\n\n                            \n    # OPTIONAL PARAMETERS\n    \n    substrings_opt=['Silicate','Phosphate','Ammonia','Sulfide' ]\n    standardizedNames=['SiOx_um_l','PO4_Filt_um_l','Ammonia','Sulfide']\n    pyco2sysNames=['total_silicate','total_phosphate','total_phosphate','total_sulfide']  # Names that pyco2sys expects in the argument list\n    \n    \n    if len(opt_param_inFile)\u003e0:  # if there is at least one optional paramter in the input file.        \n        for name, substr, pName in zip(standardizedNames, substrings_opt, pyco2sysNames):     \n            if any(substr in string for string in opt_param_user.value):  # If the optional parameter was chosen by the user\n                kwargs[pName]=df[name].to_numpy(dtype=float)              # Get the data using the standardized name\n        \n\n        \n    # MANDATORY  PARAMETERS\n\n    # Also check if the user wanted to use any other output temperature and pressure in the calculations.\n    # If they did not, the temp_out and press_out would be 'nan'\n    \n    #Set the output temperature and pressure to nan\n    Temperature_out=float('nan')\n    Pressure_out=float('nan')\n    \n    Temperature=df['CTDTmp90'].to_numpy(dtype=float)\n    kwargs['temperature']=Temperature\n    #if np.isnan(Temperature_out)==False:    \n    kwargs['temperature_out']=Temperature_out\n\n    Pressure=df['Pres_Z'].to_numpy(dtype=float)\n    kwargs['pressure']=Pressure   \n    #if np.isnan(Pressure_out)==False:    \n    kwargs['temperature_out']=Pressure_out   \n\n    Salinity=df['P_sal_CTD'].to_numpy(dtype=float)\n    kwargs['salinity']=Salinity   \n\n\n\n    #Get the values of the widget selections for the different CONSTANTS. All parameters are selected by default.\n    \n    k1k2Value=k1k2.value\n    kso4Value=kso4.value\n    boValue=bo.value\n    hfValue=hf.value\n    phscaleValue=phscale.value\n    gcValue=gc.value\n\n    kso4Value_temp=kso4Value[:2]\n    boValue_temp=boValue[:2]\n    hfValue_temp=hfValue[:2]\n    k1k2Value_temp=k1k2Value[:2]\n    phscaleValue_temp=phscaleValue[:2]\n    gcValue_temp=gcValue[:2]\n        \n    if '.' in kso4Value_temp:      \n        kso4Value_temp=kso4Value_temp[:1]\n    \n    if '.' in boValue_temp:       \n        boValue_temp=boValue_temp[:1]       \n\n    if '.' in hfValue_temp:       \n        hfValue_temp=hfValue_temp[:1]       \n        \n    if '.' in k1k2Value_temp:       \n        k1k2Value_temp=k1k2Value_temp[:1]\n              \n    if '.' in phscaleValue_temp:   \n        phscaleValue_temp=phscaleValue_temp[:1]\n        \n    if '.' in gcValue_temp:\n        gcValue_temp=gcValue_temp[:1]\n    \n    k1k2Value=int(k1k2Value_temp)\n    kso4Value=int(kso4Value_temp)\n    boValue=int(boValue_temp)\n    hfValue=int(hfValue_temp)\n    phscaleValue=int(phscaleValue_temp)\n    gcValue=int(gcValue_temp)\n        \n    #Add them as arguments for pyco2sys\n    kwargs['opt_k_carbonic']=k1k2Value\n    kwargs['opt_k_bisulfate']=kso4Value\n    kwargs['opt_total_borate']=boValue\n    kwargs['opt_k_fluoride']=hfValue\n    kwargs['opt_gas_constant']=gcValue\n\n\n    # Import PyCO2SYS\n    import PyCO2SYS as pyco2\n\n    # Run pyCO2SYS!\n    output_dict = pyco2.sys(**kwargs)\n\n    \n    Output(df,output_dict)","key":"uIWmePymD2"},{"type":"outputs","id":"M3ovHUwbAkMX33uCG5VXK","children":[],"key":"BGwi4XCrX2"}],"key":"T2jbzbtCwP"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def Output(df,output_dict):\n    \n#     ## Added to make the \"continue button\" to continue the process into the Sea Ice Concentration retrieval: \n    def on_button_sic(b):\n        continue_sic()\n\n    outsic=widgets.Output()\n    @outsic.capture()\n    def continue_sic():\n        ccadi_uc3_mapping() # sea ice concentration processing\n\n    ###########################################\n    \n    \n    #The dictionary output_dict is uneven. Some elements are just a single int, string or float. The length of 'par1' will always be the longest length (it holds the first of the two key parameters from the input file)\n    #For the values in the dictionary that are not single values, they are arrays. \n    #To be able to create even data frames, we need to seperate the values in the array and create a list.\n    #Otherise, the array is saved as one value for each key, instad of a list of multiple values.\n    \n    \n    longlength=len(output_dict['par1'])\n    newlist=[]\n\n    for val in output_dict.values():\n\n        #if value is a single integer\"\n        if isinstance(val, int):\n            list0=[val] * longlength\n            newlist.append(list0)\n\n        elif isinstance(val, str):\n            list1=[val] * longlength\n            newlist.append(list1)\n\n        elif isinstance(val, float):\n            list2=[val] * longlength\n            newlist.append(list2)\n        else:\n            arr=val\n            list3 = arr.tolist()\n            newlist.append(list3)\n            \n            \n    #Creae a new dict that has keys associated with a list of values, all of the same length.            \n    newdict={}\n    i=0\n    for key in output_dict.keys():\n        newdict[key]=newlist[i]\n        i=i+1\n\n\n    #Create a new dataframe and save as csv.\n    output_df=pd.DataFrame.from_dict(newdict)\n\n    #Merge this resulting data frame with extra variables from the input file that were not used in calculations\n    cols_to_use = df.columns.difference(output_df.columns)   #variales that are different from those in output file\n    input_subset=df[cols_to_use]\n    merged_df = pd.concat([output_df,input_subset] , axis=1)  #Merged dataframe\n\n        \n    # Organize data frame so that specific varibales are at the front\n    front_metadata=['project name','platform name','Cruise', 'Station','sample date','TIME','latitude','longitude','sample depth','Cast','Bottle']\n    \n    #Loop through the list of metadata variables that should be at the front\n    col_position=-1\n    for var in front_metadata: \n        for col in merged_df.columns:                                  # Loop through all the columns in dataframe\n            stripped_string = re.sub(\"[^0-9a-zA-Z]+\", \" \",col)         # Strip the column headers of all non- laphanumeric characters\n            if var.lower() in stripped_string.lower():                 # Check for column name regardless of case\n                popped_col_data=merged_df.pop(col)                     # Pop the column from daat frame\n                col_position=col_position+1                            # Find the next front position\n                merged_df.insert(col_position, col, popped_col_data)   # Place variable at position\n\n    front_data=['saturation_aragonite', 'saturation_aragonite_out','saturation_calcite','saturation_calcite_out','pCO2','fCO2','bicarbonate','pH_total']\n\n    #Loop through the list of calculated carbonate chemistry variables that should be at the front\n    for var in front_data: \n        for col in merged_df.columns:                                  # Loop through all the columns in dataframe\n            if col==var:                 \n                popped_col_data=merged_df.pop(col)                     # Pop the column from daat frame\n                col_position=col_position+1                            # Find the next front position\n                merged_df.insert(col_position, col, popped_col_data)   # Place variable at position\n    \n    \n    #Remove par1, par2, par1 and par2 types- added by pyco2, not needed by user \n    merged_df.pop('par1')\n    merged_df.pop('par2')\n    merged_df.pop('par1_type')\n    merged_df.pop('par2_type')\n\n    #Remove duplicate columns from final data frame\n    duplicateColumnNames = list()\n\n    for x in range(merged_df.shape[1]):                   # Iterate over all the columns in dataframe\n        col_name1= merged_df.columns[x]                   # Select column at xth index.\n\n        for y in range(x + 1, merged_df.shape[1]):        # Iterate over all the columns in DataFrame from (x+1)th index till end\n            col_name2= merged_df.columns[y]\n            \n            if col_name1.lower()==col_name2.lower():      # Check if column names are the same regardless of case\n                duplicateColumnNames.append(col_name1)\n                continue\n                \n            if '.1' in col_name1:                         # Check if there is a duplicate (same case), pandas will save this with a .1 at the end of the duplicated variable\n                col_name1_stripped=col_name1.strip('.1')  # Remove .1 and check again for equality \n                if col_name1_stripped.lower()==col_name2.lower():\n                    duplicateColumnNames.append(col_name1)\n                    continue\n                \n            if '.1' in col_name2:\n                col_name2_stripped=col_name2.strip('.1')\n                if col_name1.lower()==col_name2_stripped.lower():\n                     duplicateColumnNames.append(col_name2)\n                        \n    merged_df = merged_df.drop(columns=duplicateColumnNames)  #Drop all duplicates\n    merged_df=merged_df.dropna(axis=1,how='all')              #Drop all empty columns\n\n    # OUTPUT FILE----------------------------------------------------------------------\n    if os.path.isfile(os.path.join(\"2016_int_btl_csv\", \"merged_btl_nutrient_pyco2sys.csv\"))==True:  \n        os.remove(os.path.join(\"2016_int_btl_csv\", \"merged_btl_nutrient_pyco2sys.csv\"))\n    merged_df.to_csv(os.path.join(\"2016_int_btl_csv\", \"merged_btl_nutrient_pyco2sys.csv\"), index=False)   \n    # OUTPUT FILE----------------------------------------------------------------------\n\n    \n    printmd('**\u003cbr /\u003ePCO2sys ran successfully! Output file is saved as merged_btl_nutrient_pyco2sys.csv**')\n    printmd(\"\u003cbr /\u003e**Retrieving ice concentration now...**\")\n \n    # add the \"continue button\" on the GUI ######################################\n    gridwindow={}\n    vbox_widgets = []\n    gridwindow['grid'] = widgets.GridspecLayout(1,1)\n\n    continue_button2=widgets.Button(\n        description='Continue',\n        disabled=False,\n        button_style='', \n        tooltip='Click me',\n        icon=''\n        )\n    gridwindow['to_sic'] =  widgets.HBox(children=[continue_button2])\n    vbox_widgets.append(gridwindow['to_sic'])\n    gridwindow['grid'][0, 0] = widgets.VBox(children=vbox_widgets)\n    display(gridwindow['grid'])\n    continue_button2.on_click(on_button_sic)\n    display(outsic)\n    ##################################################\n\n    ","key":"s8MvVohYib"},{"type":"outputs","id":"bdGq81v3dTK62lgGHdaDP","children":[],"key":"xdCbn8k0wV"}],"key":"DCPiZEU1Ix"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"L = mlp.Lock()\nclass addSeaIceConcentration:\n    def __init__(self, inputfile):\n        self.inputfile = inputfile\n\n    def createShapefile(self, df, output_shp, time_header, prglabel):\n        ''' This function creates a shapefile from the geographical locations inside the input CSV file.\n            The coordinate system used for the output shapetile is the World Geodetic System (WGS) 1984.\n            Both Latitude and Longitude are in decimal degrees'''\n        prglabel.value = 'Creating the final shapefile...'\n        shpfile = os.path.join(os.path.dirname(self.inputfile), output_shp, output_shp + '.shp')\n        if not os.path.exists(os.path.join(os.path.dirname(self.inputfile), output_shp)):\n            os.makedirs(os.path.join(os.path.dirname(self.inputfile), output_shp))\n        driver = ogr.GetDriverByName(\"ESRI Shapefile\")\n        if os.path.exists(shpfile):\n            driver.DeleteDataSource(shpfile)\n        ds = driver.CreateDataSource(shpfile)\n        spref = osr.SpatialReference()\n        spref.ImportFromEPSG(4326)\n        layer = ds.CreateLayer('StationsLocations', spref, ogr.wkbPoint)\n        # create field to the layer\n        for c in df.columns:\n            u = list(df[c])\n            vint = [i for i in u if isinstance(i, int)]\n            vfloat = [i for i in u if isinstance(i, float)]\n            if c.__contains__(time_header):\n                layer.CreateField(ogr.FieldDefn(time_header, ogr.OFTDateTime))\n            elif c.__contains__('CIS_dates'):\n                layer.CreateField(ogr.FieldDefn('CIS_dates', ogr.OFTDateTime))\n            elif c.__contains__('Time'):\n                fieldname = ogr.FieldDefn('Time UTC', ogr.OFTString)\n                fieldname.SetWidth(20)\n                layer.CreateField(fieldname)\n            elif len(u) == len(vint):\n                df[c] = df[c].astype(float)\n                ##############################################\n                fieldname = ogr.FieldDefn(c, ogr.OFTInteger)\n                fieldname.SetPrecision(0)\n                layer.CreateField(fieldname)\n            elif len(u) == len(vfloat):\n                fieldname = ogr.FieldDefn(c, ogr.OFTReal)\n                fieldname.SetPrecision(6)\n                layer.CreateField(fieldname)\n            else:\n                df[c].astype(str)\n                fieldname = ogr.FieldDefn(c, ogr.OFTString)\n                fieldname.SetWidth(30)\n                layer.CreateField(fieldname)\n\n        c_fid = 0\n        ld = layer.GetLayerDefn()\n        lon = [i for i in df.columns if i.__contains__('longitude')].pop()\n        lat = [i for i in df.columns if i.__contains__('latitude')].pop()\n        for i in df.index:\n            # create new point object\n            point = ogr.Geometry(ogr.wkbPoint)\n            point.AddPoint(float(df[lon].values[i]), float(df[lat].values[i]))\n            # create new feature\n            featureDfn = layer.GetLayerDefn()\n            feature = ogr.Feature(featureDfn)\n            feature.SetGeometry(point)\n            for k in range(0, df.columns.__len__()):\n                fieldName = ld.GetFieldDefn(k).GetName()\n                feature.SetField(fieldName, df[df.columns[k]].values[i])\n            c_fid += 1\n            # add the new feature to the new layer\n            layer.CreateFeature(feature)\n        del layer, ds, df\n        return 0\n\n    def extractFromUniBremenAMSR2(self, prm):\n        ''' Sea Ice Concentration (SIC) from Bremen University are downloaded. The SIC located at each geographical\n        coordinate indicated in the input csv file are extracted and then added as an extra-column to the csv file. '''\n        L.acquire()\n        ddate = pd.to_datetime(prm[0])\n        dlat = prm[1]\n        dlon = prm[2]\n        q = prm[3]\n        m = datetime.strftime(ddate, '%b').lower()  # extract the month in lowercase charachter\n        y = datetime.strftime(ddate, '%Y')  # extract the year\n        with tempfile.TemporaryDirectory() as tmpDir:\n            url = r'https://seaice.uni-bremen.de/data/amsr2/asi_daygrid_swath/n6250/{0}/{1}/Arctic/asi-AMSR2-n6250-{2}-v5.4.tif'.format(\n                y, m, datetime.strftime(ddate, '%Y%m%d'))\n            if not os.path.exists(os.path.join(os.path.join(os.path.dirname(self.inputfile), 'BU_rasters'),\n                                               'asi-AMSR2_{0}.tif'.format(\n                                                   datetime.strftime(ddate, '%Y%m%d')))):\n                urllib.request.urlretrieve(url, os.path.join(tmpDir, 'asi-AMSR2.tif'))\n                if (q == 'Y'):\n                    shutil.copy2(os.path.join(tmpDir, 'asi-AMSR2.tif'),\n                                 os.path.join(os.path.join(os.path.dirname(self.inputfile), 'BU_rasters'),\n                                              'asi-AMSR2_{0}.tif'.format(\n                                                  datetime.strftime(ddate, '%Y%m%d'))))\n                    src_filename = os.path.join(os.path.join(os.path.dirname(self.inputfile), 'BU_rasters'),\n                                                'asi-AMSR2_{0}.tif'.format(\n                                                    datetime.strftime(ddate, '%Y%m%d')))\n                else:\n                    src_filename = os.path.join(tmpDir, 'asi-AMSR2.tif')\n            else:\n                src_filename = os.path.join(os.path.join(os.path.dirname(self.inputfile), 'BU_rasters'),\n                                            'asi-AMSR2_{0}.tif'.format(\n                                                datetime.strftime(ddate, '%Y%m%d')))\n            try:\n                outval = self.pointExtract(src_filename, dlat, dlon)\n                prm[4].put(prm[5])\n            except:\n                outval = np.nan\n                prm[4].put(prm[5])\n                pass\n        L.release()\n        return ([float(outval), datetime.strftime(ddate.to_pydatetime(), '%Y-%m-%d')])\n\n    def extractFromCSI(self, prm):\n        '''For each acquisition date in the csv file, differences are calculated between each one of them and each one included\n        in the CIS tar files. Then the tar file corresponding the minimum difference is choosen for the extraction\n        of the Sea Ice Concentration. '''\n        L.acquire()  # this is needed to lock each process to let them running separately without writing in a same variable at the same time\n        ddate = pd.to_datetime(prm[0])  # Acquisition date from the csv file.\n        dlat = prm[1]\n        dlon = prm[2]\n        fcis = prm[3]\n        CISRaster = prm[4]\n\n        CIS_acquisition_times = [datetime.strptime(i.split('_')[2], '%Y%m%dT%H%MZ').date() for i in fcis]\n        wq = np.array(CIS_acquisition_times)\n        CIS_acquisition_times = list(np.unique(wq))\n        csv_acquisition_time = datetime.strftime(ddate, '%Y%m%dT%H%M%S')\n        sample_date = datetime.strptime(csv_acquisition_time, '%Y%m%dT%H%M%S').date()\n        dt_abs = [abs(sample_date - each_date) for each_date in CIS_acquisition_times]\n        closest_date = CIS_acquisition_times[dt_abs.index(min(dt_abs))]\n        outraster = os.path.join(CISRaster, [i for i in fcis if i.__contains__(datetime.strftime(closest_date, '%Y%m%d'))][0][:-4] + '.tif')\n        intval = self.pointExtract(outraster, dlat, dlon)\n        outval = intval[0][0]\n        prm[5].put(prm[6])\n        L.release()  # this releases the locked process\n        return ([float(outval), datetime.strftime(closest_date, '%Y-%m-%d')])\n#         return ([float(outval), datetime.strftime(CIS_acquisition_times[s[0][0]], '%Y-%m-%d')])\n\n    def selectCISFiles(self, prm):\n        '''This function select the filenames from the CIS acquired at the nearest time as each one of the within the\n        input csv file. The output list of files will be used to download them. '''\n        L.acquire()\n        ddate = pd.to_datetime(prm[0])\n        fcislist = prm[3]\n        CIS_acquisition_times = [datetime.strptime(i.split('_')[2], '%Y%m%dT%H%MZ').date() for i in fcislist]\n        wq = np.array(CIS_acquisition_times)\n        CIS_acquisition_times = list(np.unique(wq))\n        u = datetime.strftime(ddate, '%Y%m%dT%H%M%S') # sample date\n        sample_date = datetime.strptime(u, '%Y%m%dT%H%M%S').date()\n        dt_abs = [abs(sample_date - each_date) for each_date in CIS_acquisition_times]\n        closest_date = CIS_acquisition_times[dt_abs.index(min(dt_abs))]\n        prm[5].put(prm[6])\n        L.release()\n        return [i for i in fcislist if i.__contains__(datetime.strftime(closest_date, '%Y%m%d'))][0]\n\n    def binaryretrieve(self, j):\n        '''The connection to the FTP server of the Canadian Ice Service is done in this function.\n        All the spatial coordinate are assumed to be within the region Eastern_Arctic and in the same year 2016\n        as the case of the GreenEdge data. '''\n        L.acquire()\n        i = j[0]\n        shp_for_UC3 = j[1]\n        hostname = 'sidads.colorado.edu'\n        ftp = FTP(hostname)\n        ftp.login(user='anonymous', passwd='')\n        ## This should be changed to be dynamically change depending on the region (here: Eastern_Arctic) and the year.\n        # The User Guide from the Canadian Ice Service (https://nsidc.org/data/G02171/versions/1?qt-data_set_tabs=3#qt-data_set_tabs) discribe all the possible region names\n        ftp.cwd('/pub/DATASETS/NOAA/G02171/Eastern_Arctic/2016/') \n        if not os.path.exists(os.path.join(shp_for_UC3, i)):\n            with open(os.path.join(shp_for_UC3, i), 'wb') as localfile:\n                ftp.retrbinary('RETR ' + i, localfile.write, 1024)\n        ftp.quit()\n        j[2].put(j[0])\n        L.release()\n        return 0\n\n    def fetchTarFromCIS(self, tarfile, shp_for_UC3, CISRaster, prglabel, pr, pStatus):\n        ''' This function manage the file retrieval from the CIS and then call to another function to do the vector\n        shapefiles into rasters. '''\n\n        if not os.path.exists(shp_for_UC3):\n            os.makedirs(shp_for_UC3)\n        '''For now, we assume all the data in the csv file were acquired in the same year (2016) and from\n        the same region (Eastern_Arctic) as the case of the GreenEdge data.'''\n        pool = mlp.Pool(processes=mlp.cpu_count()-2)\n        m = Manager()\n        queue = m.Queue()\n        tarfilelist = [[i, shp_for_UC3, queue] for i in tarfile]\n        s = pool.map_async(self.binaryretrieve, tarfilelist)\n        ##\n        while True:\n            if s.ready():\n                break\n            else:\n                c1 = int(queue.qsize() * 100 / len(tarfilelist))\n                pr.value=c1\n                prglabel.value = 'Fetching files from the CIS server...'\n                pStatus.value = f'{pr.value}%'\n        ##\n        del pool, s, queue, m\n        # Start a new progressbar for the shapefile converstion\n        m = Manager()\n        queue = m.Queue()\n        pr.value=0\n        prglabel.value = 'Converting shapefiles into raster files...'\n        pStatus.value = f'{pr.value}%'\n        ###################################################################\n        for f in tarfile:\n            '''Here the *.shp file have already been extracted from the *.tar file, \n            so we only need to point to it as shp_filename'''\n            shutil.unpack_archive(os.path.join(shp_for_UC3, f), shp_for_UC3, f[-3:])\n            shp_filename = os.path.join(shp_for_UC3, f[:-4] + '.shp')\n            outraster = os.path.join(CISRaster, f[:-4] + '.tif')\n            if not os.path.exists(outraster):\n                self.makeRasterFromSHP(shp_filename, outraster, 100)\n            queue.put(1)\n            c1 = int(queue.qsize() * 100 / len(tarfilelist))\n            pr.value=c1\n            pStatus.value = f'{pr.value}%'\n        del m, queue\n        return 0\n\n\n    def makeRasterFromSHP(self, shp_filename, outraster, pxlsize):\n        ''' This function handle the transformation of the vector shapefile format into rasters format.\n        The ogr python binding package is used to read the vector shepefile before their transfmation into raster.\n         Here only the Field CT holding the Sea Ice Concentration data are rasterized.\n         If needed, other Field amoung all of those included in the shapefile can be added as an additional band\n         into the output raster. '''\n        shpfile = ogr.Open(shp_filename)\n        layer = shpfile.GetLayer()\n        xmin, xmax, ymin, ymax = layer.GetExtent()\n        cols = int((xmax - xmin) / pxlsize)\n        rows = int((ymax - ymin) / pxlsize)\n        rdrive = gdal.GetDriverByName('GTiff')\n        ds = rdrive.Create(outraster, cols, rows, 1, gdal.GDT_Byte)\n        ds.SetGeoTransform([xmin, pxlsize, 0, ymax, 0, -pxlsize])\n        gdal.RasterizeLayer(ds, [1], layer, options=['ATTRIBUTE=CT'])\n        ds.SetProjection(layer.GetSpatialRef().ExportToPrettyWkt())\n        ds.GetRasterBand(1).SetNoDataValue(0)\n        del ds, rdrive, shpfile, layer\n        return 0\n\n    def pointExtract(self, src_filename, dlat, dlon):\n        ''' The extraction process is handled inside this function.\n        The GDAL python binding package is used here to read the raster files needed for the extraction.\n        The pyproj package is used to bring the geographical coordinates from the input csv to match the spatial\n         coordinate system of the rasters in order to make the extraction of the right collocated pixel with the csv data. '''\n        src_ds = gdal.Open(src_filename)\n        gt = src_ds.GetGeoTransform()\n        band = src_ds.GetRasterBand(1)\n        proj = osr.SpatialReference(wkt=src_ds.GetProjection())\n        #####\n        wgs84 = pyproj.CRS(\"EPSG:4326\")\n        rstProj = pyproj.CRS(proj.ExportToProj4())\n        #####\n        point = ogr.Geometry(ogr.wkbPoint)\n        point.AddPoint(float(dlat), float(dlon))  # to make sure the corrdinates are not in string format\n        mx, my = pyproj.Transformer.from_proj(wgs84, rstProj).transform(point.GetX(), point.GetY())\n        px = int((mx - gt[0]) / gt[1])  # x pixel\n        py = int((my - gt[3]) / gt[5])  # y pixel\n        intval = band.ReadAsArray(px, py, 1, 1)\n        del band, src_ds, point, proj, gt, mx, my, px, py\n        return intval\n\n    def getCISTarFileList(self, dlist, prglabel, pr, pStatus):\n        ''' This function extract the file list needed for the extraction. It uses the acquisition year\n        in the input csv file to locate the same year used in the FTP data endpoint in order to select the\n        files to be downloaded. '''\n        dl = pd.to_datetime(dlist)\n        csv_year = [datetime.strftime(s, '%Y') for s in dl]\n        csv_year = np.unique(csv_year)\n        fcis_gen = []\n        fcis = []\n        m = Manager()\n        queue = m.Queue()\n        for y in csv_year:\n            hostname = 'sidads.colorado.edu'\n            ftp = FTP(hostname)\n            ftp.login(user='anonymous', passwd='')\n            ''' There is more regions to be considered. Here the region Easter_Arctic is directly selected. '''\n            # TODO: Find a way to make automatic selection of the region of interest regarding the spatial extent of coordinate in the csv file used\n            ftp.cwd('/pub/DATASETS/NOAA/G02171/Eastern_Arctic/{0}/'.format(y))\n            files = ftp.nlst()  # This extract all the files within the folder named with the YEAR in.\n            ftp.quit()\n            fcis_gen.append([i for i in files if i.__contains__('cis')])\n        for i in fcis_gen:\n            fcis = fcis + i\n            queue.put(i)\n            p = int(queue.qsize()*100/len(fcis_gen))\n            pr.value=p\n            prglabel.value = 'Building file list...'\n            pStatus.value = f'{pr.value}%'\n        del fcis_gen, m, queue\n        return fcis\n\n    def ExtractionPixelValues(self, param_to_extract, q, rstsource, prglabel, pr, pStatus):\n        ''' * inputfile: Comma Separated Value (CSV) file with a header containning Date, Latitude, and Longitude.\n            * param_to_extract: name of the parameter to be extracted from the raster. This will become the name of\n            the new column that will be added to the initial csv file. Here it is about Sea_Ice_Concentration.\n            The format of the Date in the csv file should be mm/dd/yyyy.\n            The Latitude and Longitude Should be in full decimal format and their values are in the range [-180, 180].\n\n            * The Extraction Process is don using parallel computing to accelerate the process. Parallel processing is\n            very usefull here as the Extraction of the data coresponding to each rows are independent from each other.\n        '''\n\n        outfile = os.path.join(os.path.split(self.inputfile)[0],\n                               os.path.split(self.inputfile)[1][:-4] + '_{0}_{1}.csv'.format(param_to_extract,\n                                                                                             rstsource))\n        if os.path.exists(outfile):\n            os.remove(outfile)\n        df = pd.read_csv(self.inputfile, header=0, sep=',', parse_dates=True, skiprows=[1])\n        time_header=[i for i in df.columns if\n                     ((i.__contains__('Date')) or (i.__contains__('date')) or\n                      (i.__contains__('Time')) or (i.__contains__('time')))].pop()\n        if rstsource == 'BU':\n            m = Manager()\n            queue = m.Queue()\n            lon = [i for i in df.columns if i.__contains__('longitude')].pop()\n            lat = [i for i in df.columns if i.__contains__('latitude')].pop()\n            p = [[df[time_header][i], df[lat][i], df[lon][i], q, queue, i] for i in df.index]\n            if q == 'Y':\n                if not os.path.exists(os.path.join(os.path.dirname(self.inputfile), 'BU_rasters')):\n                    os.makedirs(os.path.join(os.path.dirname(self.inputfile), 'BU_rasters'))\n            pool = mlp.Pool(mlp.cpu_count() - 2)\n            s = pool.map_async(self.extractFromUniBremenAMSR2, p)\n            ##\n            while True:\n                if s.ready():\n                    break\n                else:\n                    c1=int(queue.qsize()*100/len(p))\n                    pr.value=c1 \n                    pStatus.value = f'{pr.value}%'\n            print(queue.qsize())\n            ##\n            a = np.array(s.get())\n            del s\n            b = np.transpose(a)\n            df[param_to_extract] = b[0]\n            df[time_header] = b[1]\n            del pool, m, queue\n        else:\n            CISRaster = os.path.join(os.path.dirname(self.inputfile), 'CISraster')\n            if not os.path.exists(CISRaster):\n                os.makedirs(CISRaster)\n            ''' Retrieval from the CIS server of filename list corresponding to each dataset in the csv file'''\n            fcis = self.getCISTarFileList(df[time_header], prglabel, pr, pStatus)\n            m = Manager()\n            queue = m.Queue()\n            pr.value=0\n            ''' Selection of each shapefile with a closest acquisition time to each dataset of the csv file. '''\n            lon = [i for i in df.columns if i.__contains__('longitude')].pop()\n            lat = [i for i in df.columns if i.__contains__('latitude')].pop()\n            p = [[df[time_header][i], df[lat][i], df[lon][i], fcis, CISRaster, queue, i] for i in df.index]\n            pool = mlp.Pool(mlp.cpu_count() - 2)\n            imglist = pool.map_async(self.selectCISFiles, p)\n            prglabel.value = 'Selecting CIS file...'\n            while True:\n                if imglist.ready():\n                    break\n                else:\n                    c1=int(queue.qsize()*100/len(p))\n                    pr.value=c1\n                    pStatus.value = f'{pr.value}%'\n            imgarray0 = np.array(imglist.get())\n            imgarray1 = np.unique(imgarray0)\n            imglist0 = list(imgarray1)\n            CIS_shp = os.path.join(os.path.dirname(self.inputfile), 'CIS_shp')\n            if not os.path.exists(CIS_shp):\n                os.makedirs(CIS_shp)\n            del imgarray0, imgarray1, pool, m, queue\n            '''Fetching the files from the remote server'''\n            self.fetchTarFromCIS(imglist0, CIS_shp, CISRaster, prglabel, pr, pStatus)\n            pool = mlp.Pool(mlp.cpu_count() - 2)\n            m = Manager()\n            queue = m.Queue()\n            p = [[df[time_header][i], df[lat][i], df[lon][i], fcis, CISRaster, queue, i] for i in df.index]\n            s = pool.map_async(self.extractFromCSI, p)\n            ##\n            while True:\n                if s.ready():\n                    break\n                else:\n                    c1=int(queue.qsize()*100/len(p))\n                    pr.value=c1\n                    prglabel.value = 'Extracting SIC from newly created rasters...'\n                    pStatus.value = f'{pr.value}%'\n            del imglist0\n            ##\n            a = np.array(s.get())\n            del pool, m, queue\n            b = np.transpose(a)\n            df[param_to_extract] = b[0]\n            df['CIS_dates'] = b[1]\n            del s\n            if q == 'N':\n                shutil.rmtree(os.path.join(os.path.dirname(self.inputfile), 'CISraster'))\n                shutil.rmtree(os.path.join(os.path.dirname(self.inputfile), 'CIS_shp'))\n        df.to_csv(outfile,\n                  sep=',', index=False, header=1)\n        output_shp = os.path.split(self.inputfile)[1][:-4] + '_{0}_{1}_SHP'.format(param_to_extract, rstsource) # Name of the output shapefile\n        self.createShapefile(df, output_shp, time_header, prglabel)\n        prglabel.value = 'Processing Finished!!'\n        pStatus.value = f'{pr.value}%'\n        output_gpkg = os.path.split(self.inputfile)[1][:-4] + '_{0}_{1}_gpkg'.format(param_to_extract, rstsource) # Name of the output Geopackage (gpkg) file\n        if not os.path.exists(os.path.join(os.path.dirname(self.inputfile), output_gpkg)):\n            os.makedirs(os.path.join(os.path.dirname(self.inputfile), output_gpkg))\n        gpkgfile = os.path.join(os.path.dirname(self.inputfile), output_gpkg, output_gpkg + '.gpkg')\n        os.system(f'ogr2ogr -a_srs EPSG:4326 -oo X_POSSIBLE_NAMES=Lon* -oo Y_POSSIBLE_NAMES=Lat*  -f \"GPKG\" {gpkgfile} {outfile}') # Creates the gpkg file from the shapefile. This can be created directly from the csv.\n        return output_shp\n\n    def getSeaIceSource(self, workDir, r, gLocalCopy, prglabel, pr, pStatus):\n        ''' The choice between the Sea Ice Data from the Canadian Sea Ice Service and Bremen University is handled\n         in this function. When the choice is done, another function is called to take care of the process of\n         extracting Sea Ice Concentration from the chosen data source. '''\n        if not os.path.exists(self.inputfile):\n            print(\"Input file not exists !\")\n            exit(-1)\n        if r == 1:\n            r = 'BU'\n        elif r == 2:\n            r = 'CIS'\n        else:\n            exit(-1)\n        if gLocalCopy == 'y':\n            gLocalCopy = 'Y'\n        elif gLocalCopy == 'n':\n            gLocalCopy = 'N'\n        t = datetime.now()\n        output_shp = self.ExtractionPixelValues('sea_ice_co', gLocalCopy, r, prglabel, pr, pStatus)\n        print(datetime.now() - t)\n        return output_shp\n\nclass ccadi_uc3_mapping():\n    def __init__(self):\n        ## initiate the grid to display the contents of the page ###\n        self.gridwindow={}\n        self.vbox_widgets = []\n        self.gridwindow['grid'] = widgets.GridspecLayout(1,1)\n                \n        #####\n\n         # read text\n        f=open(os.environ[\"DATA_PATH\"] + \"/md_texts/SeaIceConcentration.md\",\"r\")\n        fc=f.read()\n        f.close()\n        text_html1 = markdown.markdown(fc)\n        del fc\n        self.gridwindow['InfoSIC'] = widgets.HTML(text_html1)\n        self.vbox_widgets.append(self.gridwindow['InfoSIC'])\n        # Fields\n        self.wdField = widgets.Text(\n            value=os.path.join(\"2016_int_btl_csv\", \"merged_btl_nutrient_pyco2sys.csv\"),\n            layout=widgets.Layout(width='max-content')\n        )\n\n        self.chkb1 = widgets.Checkbox(\n            value=False,\n            description='Canadian Ice Service',\n            disabled=False,\n            indent=False\n        )\n        self.chkb2 = widgets.Checkbox(\n            value=False,\n            description='Bremen University',\n            disabled=False,\n            indent=False\n        )\n        self.chkb3 = widgets.Checkbox(\n            value=False,\n            description='Keep a local copy of the raster images',\n            disabled=False,\n            indent=False\n        )\n        self.gridwindow['checkbox'] = widgets.VBox(children=[self.chkb1, self.chkb2, self.chkb3])\n        self.vbox_widgets.append(self.gridwindow['checkbox'])\n        self.prg = widgets.IntProgress(\n            value=0,\n            min=0,\n            max=100,\n            bar_style='success',\n            style={'bar_color': 'green'},\n            orientation='horizontal',\n            layout=widgets.Layout(width='800px')\n        )\n        self.status = widgets.Label(value=f'{self.prg.value}%', layout=widgets.Layout(width='max-content'))\n        self.prg_label = widgets.Label('', layout=widgets.Layout(width='max-content'))\n        self.vbox_widgets.append(self.prg_label)\n        self.gridwindow['progressbar'] = widgets.HBox(children=[self.prg, self.status])\n        self.vbox_widgets.append(self.gridwindow['progressbar'])\n        self.okButton = widgets.Button(description=\"OK\")\n        \n        self.okButton.on_click(self.clickOkbutton)\n        #####\n        \n        self.UC3_mapping()\n\n\n    def check_checkBox(self):\n        c = 0\n        value = ''\n        q = 'n'\n        if self.chkb1.value==True:\n            value = self.chkb1.description\n            c = 2\n        if self.chkb2.value==True:\n            value = self.chkb2.description\n            c = 1\n        if (self.chkb3.value==True):\n            q = 'y'\n        return c, q\n\n\n    def clickOkbutton(self, b):\n        self.prg.value=0\n        self.prg_label.value = 'Processing...'\n        workDir = os.path.dirname(self.wdField.value)\n        if not os.path.exists(workDir):\n            os.makedirs(workDir)\n        inputfile = self.wdField.value\n        r, q = self.check_checkBox()\n        output_shp = addSeaIceConcentration(inputfile).getSeaIceSource(workDir, r, q, self.prg_label, self.prg, self.status)\n        \n\n    def UC3_mapping(self): \n        def on_button_clicked(b):\n            showmap()\n\n        out=widgets.Output()\n        @out.capture()\n        def showmap():\n\n            workDir=os.path.join(\"2016_int_btl_csv\")\n            shp=os.path.join(workDir, \"merged_btl_nutrient_pyco2sys_sea_ice_co_CIS_SHP\", \"merged_btl_nutrient_pyco2sys_sea_ice_co_CIS_SHP.shp\")\n            data_full=gpd.read_file(shp)\n                        \n            # Create a Geo-id which is needed by the Folium (it needs to have a unique identifier for each row)\n            data_full['geoid'] = data_full.index.astype(str)\n\n#             dataf_0m=data.loc[np.round(data[\"sample_dep\"].values)==1]\n            dataf_10m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==10]\n            dataf_20m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==20]\n            dataf_30m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==30]\n            dataf_40m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==40]\n            dataf_50m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==50]\n            dataf_60m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==60]\n            dataf_70m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==70]\n            dataf_80m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==80]\n            dataf_90m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==90]\n            dataf_100m=data_full.loc[np.round(data_full[\"sample_dep\"].values)==100]\n\n            ###\n\n            lonCent = (data_full.bounds.maxx + data_full.bounds.minx).mean()/2\n            latCent = (data_full.bounds.maxy + data_full.bounds.miny).mean()/2\n            # creating a map object\n            m = leafmap.folium.Map(location=(latCent,lonCent), projections=\"epsg3575\", zoom_start=6)\n            #rst = os.path.join(\"2016_int_btl_csv\",\"CISraster\",\"cis_SGRDREA_20160606T1800Z_pl_a.tif\")\n\n            ###\n            # Create the variable plot upon click on the stations on the map\n            def chart_func(df, st): #new function\n                chart_temp = alt.Chart(df).mark_line(color='red').transform_fold(\n                    fold=['CTDTmp90', 'sample_dep'], \n                    as_=['variable', 'value']).encode(\n                        x=alt.X('CTDTmp90:Q', \n                                axis=alt.Axis(title='Temperature (Â°C)', \n                                              titleColor='red'), \n                                scale=alt.Scale(domain=[df['CTDTmp90'].min(), \n                                                        df['CTDTmp90'].max()])),\n                        y=alt.Y('sample_dep:Q',\n                                axis=alt.Axis(title='Depth (m)'), \n                                scale=alt.Scale(reverse=True, \n                                                domain=[0, df['sample_dep'].max()])),\n                        color=alt.value('red')\n                )\n                chart_sal=alt.Chart(df).mark_line(color='green').transform_fold(\n                    fold=['P_sal_CTD', 'sample_dep'], \n                    as_=['variable', 'value']).encode(\n                        x=alt.X('P_sal_CTD:Q', \n                                axis=alt.Axis(title='Salinity', \n                                              titleColor='green'), \n                                scale=alt.Scale(domain=[df['P_sal_CTD'].min(), \n                                                        df['P_sal_CTD'].max()])),\n                        y=alt.Y('sample_dep:Q', \n                                axis=alt.Axis(title='Depth (m)'), \n                                scale=alt.Scale(reverse=True, \n                                                domain=[0, df['sample_dep'].max()])),\n                        color=alt.value('green')\n                )\n                ufchart=alt.layer(chart_temp, chart_sal, \n                                  title=f\"Vertical profil of Salinity and Temperature at Station: {st}\", \n                                  width=400, height=400).resolve_scale(x='independent').configure_axisTop(titleColor='green').configure_axisBottom(titleColor='red').resolve_legend(color='independent')            \n                return ufchart.to_json()\n            \n            # extract unique coordinates\n            data_full=data_full.round({'latitude':3, 'longitude':3})\n            df=data_full[['latitude', 'longitude']].drop_duplicates() # drop all duplicated coordinates and keep the row indexes\n            u=[]\n            for i in df.index:  # use the indexes (kept in the precedent lines) to build a new dataframe from df\n                u.append(data_full.values[i])\n            dg=pd.DataFrame(u, columns=data_full.columns)\n            data_coord=dg[['station', 'latitude', 'longitude']]\n            del dg\n            full_profile = leafmap.folium.FeatureGroup(name=\"Full profiles\")\n            for i, st in zip(df.index, data_coord['station'].values[:]):\n                ds0=data_full[\n                    [\n                        'sample_dep',\n                        'P_sal_CTD', \n                        'station', \n                        'CTDTmp90', \n                        'latitude', \n                        'longitude']\n                ].loc[\n                    data_full[\"station\"].values==st\n                ]\n                ds2=ds0.dropna().round({\n                    \"CTDTmp90\":2, \n                    \"P_sal_CTD\":2, \n                    'latitude': 3, \n                    'longitude':3})\n                chart=chart_func(ds0, st)\n                pp=leafmap.folium.Popup(max_width=600).add_child(leafmap.folium.VegaLite(chart, width=600))\n                full_profile.add_child(leafmap.folium.CircleMarker(\n                    location=[data_full['latitude'].values[i], data_full['longitude'].values[i]], radius=6,\n                    popup=pp,\n                ))\n            full_profile.add_to(m)\n            \n            # Select only needed columns           \n            data_10m = dataf_10m[['geoid', 'P_sal_CTD', 'station', 'sample_dep', 'CTDTmp90', 'geometry']]\n            \n            # Add data near the sea surface: 10m\n            leafmap.folium.features.GeoJson(dataf_10m,\n                                            name='Data at 10m depth',\n                                            style_function=lambda x: {'color':'transparent','fillColor':'transparent','weight':0},\n                                            tooltip=leafmap.folium.features.GeoJsonTooltip(\n                                                fields=[\n                                                    'P_sal_CTD', \n                                                    'station', \n                                                    'sample_dep', \n                                                    'CTDTmp90'],\n                                                aliases = [\n                                                    'Practical salinity from CTD', \n                                                    'Station name', \n                                                    'sample depth (m)',\n                                                    'Temperature from CTD (Â°C)'\n                                                ],\n                                                sticky=False)\n                                           ).add_to(m)\n\n\n            # Select only needed columns\n            data_20m = dataf_20m[['geoid', 'P_sal_CTD', 'station', 'sample_dep', 'CTDTmp90', 'geometry']]\n            \n            # Add data near the sea surface: 20m\n            leafmap.folium.features.GeoJson(dataf_20m,\n                                            name='Data at 20m depth',\n                                            style_function=lambda x: {'color':'transparent','fillColor':'transparent','weight':0},\n                                            tooltip=leafmap.folium.features.GeoJsonTooltip(\n                                                fields=[\n                                                    'P_sal_CTD', \n                                                    'station', \n                                                    'sample_dep', \n                                                    'CTDTmp90'],\n                                                aliases = [\n                                                    'Practical salinity from CTD', \n                                                    'Station name', \n                                                    'sample depth (m)',\n                                                    'Temperature from CTD (Â°C)'\n                                                ],\n                                                sticky=False)\n                                           ).add_to(m)\n            \n            # Select only needed columns\n            data_30m = dataf_30m[['geoid', 'P_sal_CTD', 'station', 'sample_dep', 'CTDTmp90', 'geometry']]\n            \n            # Add data near the sea surface: 30m\n            leafmap.folium.features.GeoJson(dataf_30m,\n                                            name='Data at 30m depth',\n                                            style_function=lambda x: {\n                                                'color':'transparent',\n                                                'fillColor':'transparent',\n                                                'weight':0\n                                            },\n                                            tooltip=leafmap.folium.features.GeoJsonTooltip(\n                                                fields=[\n                                                    'P_sal_CTD', \n                                                    'station', \n                                                    'sample_dep', \n                                                    'CTDTmp90'],\n                                                aliases = [\n                                                    'Practical salinity from CTD', \n                                                    'Station name', \n                                                    'sample depth (m)',\n                                                    'Temperature from CTD (Â°C)'\n                                                ],\n                                                sticky=False)\n                                           ).add_to(m)\n\n            # Select only needed columns\n            data_40m = dataf_40m[['geoid', 'P_sal_CTD', 'station', 'sample_dep', 'CTDTmp90', 'geometry']]\n            \n            # Add data near the sea surface: 40m\n            leafmap.folium.features.GeoJson(dataf_40m,\n                                            name='Data at 40m depth',\n                                            style_function=lambda x: {\n                                                'color':'transparent',\n                                                'fillColor':'transparent',\n                                                'weight':0\n                                            },\n                                            tooltip=leafmap.folium.features.GeoJsonTooltip(\n                                                fields=[\n                                                    'P_sal_CTD', \n                                                    'station', \n                                                    'sample_dep', \n                                                    'CTDTmp90'],\n                                                aliases = [\n                                                    'Practical salinity from CTD', \n                                                    'Station name', \n                                                    'sample depth (m)',\n                                                    'Temperature from CTD (Â°C)'\n                                                ],\n                                                sticky=False)\n                                           ).add_to(m)\n#           # Select only needed columns\n            data_50m = dataf_50m[['geoid', 'P_sal_CTD', 'station', \n                                  'sample_dep', 'CTDTmp90', 'geometry', \n                                  'latitude', 'longitude']]\n    \n            # Add data near the sea surface: 50m\n            leafmap.folium.features.GeoJson(dataf_50m,\n                                            name='Data at 50m depth',\n                                            style_function=lambda x: {\n                                                'color':'transparent',\n                                                'fillColor':'transparent',\n                                                'weight':0\n                                            },\n                                            tooltip=leafmap.folium.features.GeoJsonTooltip(\n                                                fields=[\n                                                    'P_sal_CTD', \n                                                    'station', \n                                                    'sample_dep', \n                                                    'CTDTmp90'],\n                                                aliases = [\n                                                    'Practical salinity from CTD', \n                                                    'Station name', \n                                                    'sample depth (m)',\n                                                    'Temperature from CTD (Â°C)'\n                                                ],\n                                                sticky=False)\n                                           ).add_to(m)\n\n#             ######################################################################################################################\n\n            leafmap.folium.LayerControl().add_to(m)\n            display(m)\n        \n        self.showmap_button=widgets.Button(\n                description='Show Map',\n                disabled=False,\n                button_style='', \n                tooltip='Click me',\n                icon=''\n                )\n        self.gridwindow['ok_and_continue'] = widgets.HBox(children=[self.okButton, self.showmap_button])\n        self.vbox_widgets.append(self.gridwindow['ok_and_continue'])\n        \n        self.gridwindow['grid'][0, 0] = widgets.VBox(children=self.vbox_widgets)  #\n        \n        self.accordion0 = widgets.Accordion(\n            children=[widgets.HBox(children = [self.gridwindow['grid'][0, 0]])]\n        )\n        self.accordion0.set_title(0, 'Adding Sea Ice Concentrations into the combined BTL_Nutrient file.')\n        display(self.accordion0)\n\n        self.showmap_button.on_click(on_button_clicked)\n        display(out)\n    \n\n\n    ","key":"iQS83I8vJw"},{"type":"outputs","id":"FVfgoqebrLG7yUOSSik7z","children":[],"key":"vkBYXRIosf"}],"key":"MiajehcXnS"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"merging_gui_jupiter()","key":"KzduVsgE29"},{"type":"outputs","id":"FY7jiOdGeGtBoJQzLrBsu","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/markdown":{"content":"\u003ch1\u003e\u003cb\u003eMerging bottle file with the nutrient file\u003c/b\u003e\u003c/h1\u003e","content_type":"text/markdown"},"text/plain":{"content":"\u003cIPython.core.display.Markdown object\u003e","content_type":"text/plain"}}},"children":[],"key":"aU8pqbrIXc"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"application/vnd.jupyter.widget-view+json":{"content":"{\"model_id\":\"fc53ed95b9264e1687bb6c460954e5c9\",\"version_major\":2,\"version_minor\":0}","content_type":"application/vnd.jupyter.widget-view+json"},"text/plain":{"content":"GridspecLayout(children=(VBox(children=(HTML(value='\u003ch2\u003e\u003cb\u003eInformation about the Nutrient file and BTL files\u003c/â€¦","content_type":"text/plain"}}},"children":[],"key":"eLoOpab9Hk"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"application/vnd.jupyter.widget-view+json":{"content":"{\"model_id\":\"49422a0bb8be44bdae406b19882b2a6e\",\"version_major\":2,\"version_minor\":0}","content_type":"application/vnd.jupyter.widget-view+json"},"text/plain":{"content":"Output()","content_type":"text/plain"}}},"children":[],"key":"ekqGR2Dbsy"},{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":9,"metadata":{},"data":{"text/plain":{"content":"\u003c__main__.merging_gui_jupiter at 0x7f0b9779c6d0\u003e","content_type":"text/plain"}}},"children":[],"key":"S6xUAVkhh5"}],"key":"qvl2WKiKK5"}],"key":"xSANu18Tfg"}],"key":"PV65tW19pw"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Important! You must generate a Specklia access key before running this workbook","url":"/notebooks/d-viewer-specklia-example","group":"Notebooks"},"next":{"title":"SICE","url":"/notebooks/sice","group":"Notebooks"}}},"domain":"http://localhost:3000"},"project":{"subject":"Notebook examples","title":"PolarTEP Notebooks","description":"Collection of examples relevant to the PolarTEP","github":"https://github.com/gtif-cerulean/polartep_notebooks","id":"5aa0318b-5bc1-41e2-b1d4-053e8b61961b","exports":[],"bibliography":[],"index":"readme","pages":[{"title":"Notebooks","level":1},{"slug":"notebooks.d-viewer-specklia-example","title":"Important! You must generate a Specklia access key before running this workbook","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.ccadi-uc3","title":"Ccadi U C3","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.sice","title":"SICE","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"notebooks.xcube-tutorial","title":"PolarTEP eScience Lab:  Using XCube in Polar-TEP to Generate NDVI","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2}]}}},"actionData":null,"errors":null},"future":{"unstable_dev":false,"unstable_postcss":false,"unstable_tailwind":false,"v2_errorBoundary":true,"v2_headers":true,"v2_meta":true,"v2_normalizeFormMethod":true,"v2_routeConvention":true}};</script><script type="module" async="">import "/polartep_notebooks/build/manifest-86A905A4.js";
import * as route0 from "/polartep_notebooks/build/root-CXYA7X5D.js";
import * as route1 from "/polartep_notebooks/build/routes/$-JRBPULBO.js";
window.__remixRouteModules = {"root":route0,"routes/$":route1};

import("/polartep_notebooks/build/entry.client-PCJPW7TK.js");</script></body></html>